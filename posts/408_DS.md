---
title: 408ä»£ç é¢˜å­¦ä¹ ç¬”è®°
description: ä½¿ç”¨èµ„æ–™:Bç«™-é˜¿è¾‰ä¸ä¼šæ•²ä»£ç  | ä»å…¥é—¨åˆ°è‡ªæš´è‡ªå¼ƒ
tags: [408]
categories: [408]
articleGPT: è¿™æ˜¯ä¸€ç¯‡å‘ç–¯æ–‡ç« .
---

# 408 ä»£ç é¢˜å­¦ä¹ ç¬”è®°

> å¿ƒè·¯å†ç¨‹:
>
> - -> è¿™è¿˜å¯ä»¥æ¥å—
> - -> è¿™ä¸œè¥¿å¥½åƒå¾—èƒŒä¸€èƒŒ
> - -> è¿™æ˜¯ä¸ªæ•°å­¦é¢˜
> - -> è¿™æ˜¯ç„å­¦
> - -> ç‹—ä¸œè¥¿å‹æ ¹æ²¡æƒ³è®©æˆ‘å†™å‡ºæ¥ ğŸ˜¡

## 1. é¡ºåºè¡¨

### 1.1. é¡ºåºè¡¨çš„å®šä¹‰

#### 1.1.1. é™æ€å®šä¹‰é¡ºåºè¡¨

```c
#define MaxSize 100
typedef struct SqList{
    int data[MaxSize];
    int length;
} SqList;

SqList L;
L.data[0] = 0;
```

#### 1.1.2. åŠ¨æ€å®šä¹‰é¡ºåºè¡¨

```c
typedef struct {
    int *data;
    int MaxSize,length;
} SqList;

SqList L2;
L2.data = (int*)malloc(sizeof(int)*L2.MaxSize);
L2.data[0] = 1;
```

### 1.2. é¡ºåºè¡¨çš„éå†

```c
void ListVisit(SqList L){
    if(L.length == 0){
        return;
    }
    for(int i = 0; i < L.length; i++){
        printf("%d", L.data[i]);
    }
}
```

### 1.3. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼ŒæŸ¥æ‰¾é¡ºåºè¡¨ L ä¸­ç¬¬ä¸€ä¸ªå€¼ä¸º x çš„å…ƒç´ ï¼Œè‹¥æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…¶ä½åºï¼Œè‹¥æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å› 0ã€‚

```c
int Search_X(SqList L,int x){
    if(L.length == 0){
        return 0;
    }
    for(int i = 0; i < L.length; i++){
        if(x == L.data[i]){
            return i+1;
        }
    }
    return 0;
}
```

### 1.4. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, å…¶å­˜å‚¨çš„æ‰€æœ‰æ•°æ®å…ƒç´ å‡ä¸ºé 0 æ•´æ•°ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼ŒæŸ¥æ‰¾ L ä¸­ç¬¬ i ä¸ªå…ƒç´ å¹¶è¿”å›å…¶å€¼ã€‚

```c
int Search_I(SqList L, int i){
    if(L.length == 0){
        return 0;
    }
    // åˆæ³•
    if(i <= L.length && i > 0){
        return L.data[i-1];
    }
    // éæ³•
    return 0;
}
```

### 1.5. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨ L çš„ç¬¬ i ä¸ªä½ç½®æ’å…¥æ–°å…ƒç´  xã€‚è‹¥ä¸èƒ½æ­£å¸¸æ’å…¥ï¼Œåˆ™è¿”å› false, è¡¨ç¤ºæ’å…¥å¤±è´¥ï¼›è‹¥èƒ½å¤Ÿæ­£å¸¸æ’å…¥ï¼Œåˆ™åœ¨é¡ºåºè¡¨ L ä¸­çš„ç¬¬ i ä¸ªä½ç½®æ’å…¥æ–°å…ƒç´  x, è¿”å› true, è¡¨ç¤ºæ’å…¥æˆåŠŸã€‚

```c
bool ListInsert(SqList &L,int i,int x){ // æ”¹å˜Léœ€è¦åŠ &
    if(i < 1 || i>L.length || L.MaxSize == L.length){
        return false;
    }
    // ä»åå¾€å‰éå†
    for(j = L.length;j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = x;
    L.length++;
    return true;
}
```

### 1.6. å‡è®¾æœ‰ä¸€ä¸ªéç©ºé¡ºåºè¡¨ L, å…¶ä¸­çš„å…ƒç´ éé€’å‡æœ‰åºæ’åˆ—ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åœ¨æ’å…¥å…ƒç´  x åä¿æŒè¯¥é¡ºåºè¡¨ä»ç„¶éé€’å‡æœ‰åºæ’åˆ—ï¼Œå‡è®¾æ’å…¥æ“ä½œè‚¯å®šæˆåŠŸï¼Œæ’å…¥æˆåŠŸåè¿”å›æ’å…¥å…ƒç´ æ‰€åœ¨ä½ç½®ã€‚

```c
int ListInsert(SqList &L, int x){
    int i;
    for(i = L.length; i > 0 && L.data[i-1]>=x; i--){
        L.data[i] = L.data[i-1];
    }
    L.data[i+1] = x;
    L.length++;
    return i+1;
}
```

å¦æœ‰

```c
int ListInsert(SqList &L, int x){
    int i;
    // æ‰¾åˆ°æ’å…¥ä½ç½®i
    for(i = 0; i < L.length; i++){
        if(L.data[i] > x){
            break;
        }
    }
    // ç§»åŠ¨i+1åé¢çš„å…ƒç´ 
    for(int j = L.length; j>=i+1; j--){
        L.data[j] = L.data[j-1];
    }
    return i;
}
```

### 1.7. åˆ é™¤é¡ºåºè¡¨ L ä¸­ç¬¬ i ä¸ªä½ç½®çš„å…ƒç´ ï¼Œè‹¥åˆ é™¤å¤±è´¥ï¼Œåˆ™è¿”å› false; è‹¥åˆ é™¤æˆåŠŸï¼Œåˆ™å°†è¢«åˆ å…ƒç´ çš„å€¼èµ‹ç»™å¼•ç”¨å‚æ•° x, ç„¶åè¿”å› trueã€‚

```c
bool Delete_I(SqList &L, int &x, int i){
    if(L.length == 0 || i < 1 || i > L.length){
        return false;
    }
    x = L.data[length-1];
    for(int j = i; j < L.length; j++){
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
```

### 1.8. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, L æœ‰æœ€å°å€¼ä¸”æœ€å°å€¼å”¯ä¸€ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ é™¤ L ä¸­çš„æœ€å°å€¼å…ƒç´ å¹¶ç”±å‡½æ•°è¿”å›è¢«åˆ å…ƒç´ çš„å€¼ã€‚

```c
int Delete_min(SqList &L){
    int min = L.data[0]; // æœ€å°å€¼æ˜¯è°
    int pos = 0; // åˆå§‹ä½ç½®æ˜¯å“ª
    for(int i = 1; i < L.length; i++){
        if(min > L.data[i]){
            min = L.data[i];
            pos = i;
        }
    }
    for(int j = pos; j < L.length; j++){
        L.data[j] = L.data[j+1];
    }
    L.length--;
    return min;
}
```

### 1.9. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, è¯·ç¼–å†™ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º O(ä»¥ã€ç©ºé—´å¤æ‚åº¦ä¸º O(1)çš„ç®—æ³•ï¼Œåˆ é™¤é¡ºåºè¡¨ L ä¸­æ‰€æœ‰å€¼ä¸º x çš„å…ƒç´ ã€‚

```c
// æ’é˜Ÿæ³•
void Del_x(SqList &L,int x){
    if(L.length == 0){
        return;
    }
    int j = 0;
    for(int i = 0;i <= L.length;i++){
        if(L.data[i] != x){
            L.data[j] = L.data[i];
            j++;
        }
    }
    L.length = j;
}
```

### 1.10. å‡è®¾æœ‰ä¸€ä¸ªé¡ºåºè¡¨ L, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ é™¤ L ä¸­å…ƒç´ å€¼åœ¨ç»™å®šå€¼ s ä¸ t ä¹‹é—´ï¼ˆåŒ…å« s å’Œ t, è¦æ±‚ s < t)çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥é¡ºåºè¡¨ä¸ºç©ºæˆ–ç»™å®šçš„ s å’Œ t å€¼ä¸åˆç†ï¼Œåˆ™è¿”å› false, è‹¥æ‰§è¡ŒæˆåŠŸåˆ™è¿”å› trueã€‚

```c
// è®¡æ•°æ³•
bool Delete_Between(SqList &L, int s, int t){
    if(L.length == 0 || s >=t || s < 1 || t >= L.length){
        return false;
    }
    int p = 0;
    for(int i = 0; i >= 0; i++){
        if(L.data[i] >= s && L.data[i] <= t){
            p++;
        }else {
            L.data[p] = L.data[i];
        }
    }
    L.length = L.length - p;
    return true;
}
```

### 1.11. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨ä¸€ä¸ªæœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å€¼é‡å¤çš„å…ƒç´ ï¼Œä½¿è¯¥é¡ºåºè¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼å‡ä¸åŒ

```c
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int j = 1;
    for(int i = 1; i < L.length; i++){
        if(L.data[i] != L.data[i-1]){
            L.data[j] = L.data[i];
        }
    }
    L.length = j;
}
```

### 1.12. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨ä¸€ä¸ªæ— åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å€¼é‡å¤çš„å…ƒç´ ï¼Œä½¿è¯¥é¡ºåºè¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼å‡ä¸åŒä¸”åˆ é™¤åçš„å…ƒç´ é—´ç›¸å¯¹ä½ç½®ä¿æŒä¸å˜ã€‚

```c
// æ’é˜Ÿæ³•
void Del_Iterate(SqList &L){
    if(L.length <= 1){
        return;
    }
    int k = 1; // æ–°é¡ºåºè¡¨çš„é•¿åº¦
    int j; // è®©ç¬¬ä¸€å±‚å¾ªç¯èƒ½å¤Ÿè·å–j
    for(int i = 1; i <= L.length; i++){
        for(j = 1; j < i; j++){
            if(L.data[i] == L.data[j]){
                break; // åœæ­¢æ¯”è¾ƒ
            }
        }
        if(j == i){ // æ²¡æœ‰é‡å¤å€¼
            L.data[k] = L.data[i]; // é‡æ’
            k++;
        }
    }
    L.length = k;
}
```

### 1.13. è¯·è®¾è®¡ä¸€ä¸ªå°½å¯èƒ½é«˜æ•ˆçš„ç®—æ³•ï¼Œå°†é¡ºåºè¡¨ L ä¸­çš„æ‰€æœ‰å…ƒç´ é€†ç½®ï¼Œè¦æ±‚ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ä¸º O(1)

```c
void Reverse(SqList &L){
    if(L.length == 0){
        return;
    }
    for(int i = 0,j = L.length - 1; i < j; i++,j--){ // å®šä¹‰åŒå˜é‡
        temp = L.data[i];
        L.data[i] = L.data[j];
        L.data[j] = temp;
    }
}
```

### 1.14. å·²çŸ¥ä¸€ä¸ªä¸€ç»´æ•°ç»„ A [m+n] ä¸­ä¾æ¬¡å­˜æ”¾äº†ä¸¤ä¸ªçº¿æ€§è¡¨(a1, a2,â€¦, am)å’Œ(b1, b2,â€¦, bn), è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†æ•°ç»„ä¸­çš„ä¸¤ä¸ªçº¿æ€§è¡¨ä½ç½®äº’æ¢ï¼Œå³è®¾è®¡ä¸€ä¸ªç®—æ³•å°†åŸæ•°ç»„(a1, a2,â€¦, am, b1, b2,â€¦, bn)å˜ä¸º(b1, b2,â€¦, bn, a1, a2,â€¦, am)ã€‚

æ³•ä¸€:

```c
void Swap(int A[], int m, int n){
    int B[m+n];
    for(int i = 0; i < m+n; i++){
        B[i] = A[i];
    }
    for(int i = m; i < m+n; i++){
        A[i - m] = B[m];
    }
    for(int i = 0; i < m; i++){
        A[i + m] = B[i];
    }
}
```

æ³•äºŒ:

```c
// ä¸‰æ¬¡é€†ç½®,æ— è¾…åŠ©æ•°ç»„
void Reverse(int A[], int low, int high){
    int temp;
    for(int i = low, j = high; i < j; i++,j--){
        temp = A.data[i];
        A.data[i] = A.data[j];
        A.data[j] = temp;
    }
}

void Swap(int A[], int m, int n){
    Reverse(A[], 0, m-1);
    Reverse(A[], m, m+n-1);
    Reverse(A[], 0, m+n-1);
}
```

### 1.15. ç°æœ‰ä¸¤ä¸ªéé€’å‡æœ‰åºçš„é¡ºåºè¡¨ A å’Œ B, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†ä¸¤ä¸ªé¡ºåºè¡¨ A å’Œ B åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ <span style="color:#FF0000;"> éé€’å‡ </span> æœ‰åºé¡ºåºè¡¨ Cã€‚

```c
// è¿™æ˜¯é¢˜ç›®ç»™å‡ºçš„è¡¨çš„ç»“æ„
typedef struct {
    int *data;
    int length,MaxSize;
} SqlList;

void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i=0,j=0,k=0; // å¾ªç¯å˜é‡
    while(i < A.length && j < B.length){
        if(A.data[i] <= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i++;
        }else {
            C.data[k] = B.data[j];
            k++;
            j++;
        }
    }
    while(i < A.length){
        C.data[k] = A.data[i];
        k++;
        i++;
    }
    while(j < B.length){
        C.data[k] = B.data[j];
        k++;
        j++;
    }
    C.length = k;
    return true;
}
```

### 1.16. ç°æœ‰ä¸¤ä¸ªéé€’å‡æœ‰åºçš„é¡ºåºè¡¨ A å’Œ B, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†ä¸¤ä¸ªé¡ºåºè¡¨ A å’Œ B åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ <span style="color:#FF0000;"> éé€’å¢ </span> æœ‰åºé¡ºåºè¡¨ Cã€‚

```c
void Merge(SqlList A, SqList B, SqList &C){
    if(A.length == 0 && B.length == 0 || A.length+B.length > C.MaxSize){
        return false;
    }
    int i = A.length - 1;
    int j = B.length - 1;
    int k = 0;
    while(i >=0 && j >=0){
        if(A.data[i] >= B.data[j]){
            C.data[k] = A.data[i];
            k++;
            i--;
        }else {
            C.data[k] = B.data[j];
            k++;
            j--;
        }
    }
    while(i >= 0){
        C.data[k] = A.data[i];
        k++;
        i--;
    }
    while(j >= 0){
        C.data[k] = B.data[j];
        k++;
        j--;
    }
    C.length = k;
    return true;
}
```

### 1.17. ç»™å®šä¸‰ä¸ªåºåˆ— Aã€Bã€C, ä¸‰ä¸ªåºåˆ—çš„é•¿åº¦å‡ n ä¸ºä¸”æ¯ä¸ªåºåˆ—éƒ½æ˜¯é€’å¢çš„ï¼Œè¯·è®¾è®¡ä¸€ä¸ªæ—¶é—´ä¸Šå°½å¯èƒ½é«˜æ•ˆçš„ç®—æ³•ï¼Œé€è¡Œè¾“å‡ºåŒæ—¶å­˜åœ¨äºè¿™ä¸‰ä¸ªåºåˆ—ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„ A ä¸º{4,2,3,6}ï¼Œæ•°ç»„ B ä¸º{-5,0,2,6}ï¼Œæ•°ç»„ C ä¸º{1,2,4,6}ï¼Œåˆ™é€è¡Œè¾“å‡º 2 å’Œ 6ã€‚

```c
// æš´åŠ›è§£å°±æ˜¯3ä¸ªforå¾ªç¯
// ...
//è¾ƒå°å€¼å‘è¾ƒå¤§å€¼é æ‹¢
int max(int A, int B, int C){
    int max;
    if(A > B){
        max = A;
    } else {
        max = B;
    }
    if(max > C){
        return max;
    } else {
      return C;
    }
}

void PrintSame(int A[], int B[], int C[]){
    int i=0,j=0,k=0;
    int m;
    while(i<A.length && j<B.length && k<C.length){
        if(A.data[i] == B.data[j] && A.data[i] == C.data[k]){
            printf("%d/n",A.data[i]);
        }
        m = max(A.data[i],B.data[j],C.data[k])
        if(A.data[i]<m){
            i++;
        }
        if(B.data[j]<m){
            j++;
        }
        if(C.data[k]<m){
            k++;
        }
    }
}
```

## 2. é“¾è¡¨

### 2.1. å•é“¾è¡¨çš„ç»“æ„ä½“å®šä¹‰

```c
typedef struct LNode{
    int data;
    struct LNode *next;
} LNode,*LinkList;

// struct LNode -> Lnode
// struct LNode* -> LinkList
// LinkList p -> LNode *p

// å¸¦å¤´ç»“ç‚¹
void InitList1(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
}

bool IsEmptyList1(LinkList L){
    if(L->next == NULL){
        return true;
    }else {
        return false;
    }
}
// ä¸å¸¦å¤´ç»“ç‚¹
void InitList2(LinkList &L){
    L = NULL;
}

bool IsEmptyList2(LinkList &L){
    if(L == NULL){
        return true;
    }else {
        return false;
    }
}

// æ³¨:é“¾è¡¨ä¸å­˜åœ¨L.dataä¹‹ç±»æ“ä½œ
```

### 2.2. éå†è¾“å‡ºå•é“¾è¡¨ L ä¸­çš„å€¼

```c
void LNodeList(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next;
    while(p != NULL){
        printf("%d",p->data);
        p = p->next;
    }
}
```

### 2.3. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L ä¸­ç¬¬ i ä¸ªæ•°æ®ç»“ç‚¹çš„ä½ç½®ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™è¿”å›æŒ‡å‘è¯¥ç»“ç‚¹çš„æŒ‡é’ˆï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULL

```c
LNode *Search_i(LinkList L, int i){
    if(L->next == NULL || i < 1){ // åˆ¤ç©º
        return;
    }
    LNode *p = L->next;
    int k = 1;
    while(p != NULL){
        if(i = k){
            return p;
        }
        p = p->next;
        k++;
    }
    return NULL; // è¯´æ˜ i å¤ªå¤§äº†
}
```

### 2.4. è®¡ç®—å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L ä¸­æ•°æ®ç»“ç‚¹çš„ä¸ªæ•°ã€‚

```c
int DataNum(LinkList L){
    if(L->next == NULL){
        return 0;
    }
    LNode *p = L->next;
    int k = 0;
    while(p != NULL){
        p = p->next;
        k++;
    }
    return k;
}
```

### 2.5. åœ¨ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„éé€’å‡æœ‰åºå•é“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªå€¼ä¸º x çš„æ–°ç»“ç‚¹ï¼Œä½¿å¾—æ’å…¥æ–°ç»“ç‚¹åé“¾è¡¨ä¾ç„¶éé€’å‡æœ‰åº

```c
void InsertList(LinkList &L, int x){
    LNode *p = L->next, *pre = L;
    while(p != NULL){
        if(p->data > x){
            break;
        }
        pre = p;
        p = p->next;
    }
    LNode *s = (LNode*)malloc(sizeof(LNode));
    s->data = x;
    s->next = p;
    pre->next = s;
}
```

### 2.6. é‡‡ç”¨å¤´æ’æ³•åœ¨å¤´æŒ‡é’ˆ L å¤„å»ºç«‹ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼Œè¾“å…¥-1 è¡¨ç¤ºç»“æŸï¼Œå¤´æ’ç»“æŸåè¿”å›å»ºç«‹çš„å•é“¾è¡¨ã€‚

```c
LinkList HeadInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    LNode *x
    int i;
    scanf("%d",&i);
    while(i != -1){
        x = (*LNode)malloc(sizeof(LNode));
        x->data = i;
        x->next = L->next;
        L->next = i;
        scanf("%d",&i);
    }
    return L;
}
```

### 2.7. é‡‡ç”¨å°¾æ’æ³•åœ¨å¤´æŒ‡é’ˆ L å¤„å»ºç«‹ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼Œè¾“å…¥-1 è¡¨ç¤ºç»“æŸï¼Œå°¾æ’ç»“æŸåè¿”å›å»ºç«‹çš„å•é“¾è¡¨ã€‚

```c
LinkList TailInsert(LinkList &L){
    L = (LinkList)malloc(sizeof(LNode));
    LNode *r = L; // å°¾æŒ‡é’ˆ
    LNode *s;
    int x;
    scanf("%d",&x);
    while(x == -1){
        s = (LNode*)malloc(sizeof(LNode)) // ä¸ºç»“ç‚¹åˆ†é…å†…å­˜ç©ºé—´
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL; // å°¾ç»“ç‚¹çš„nextæŒ‡é’ˆç½®ç©º
    return L;
}
```

### 2.8. è¯•ç¼–å†™ç®—æ³•å°†ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L å°±åœ°é€†ç½®ï¼Œæ‰€è°“â€œå°±åœ°â€æ˜¯æŒ‡ç©ºé—´å¤æ‚åº¦ä¸º O(1)ã€‚

```C
void Reverse(LinkList &L){
    if(L->next == NULL){
        return;
    }
    LNode *p = L->next,*r;
    L->next = NULL; // å°†å°¾ç»“ç‚¹nextç½®ç©º
    while(r->next = NULL){
        r = p->next; // é˜²æ–­é“¾æŒ‡é’ˆ
        p->next = L->next;
        L->next = p;
        p = r;
    }
}
```

### 2.9. å°†ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ A åˆ†è§£ä¸ºä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ A å’Œ B, ä½¿å¾— A è¡¨ä¸­å«æœ‰åŸè¡¨ä¸­ä½åºä¸ºå¥‡æ•°çš„ç»“ç‚¹ï¼ŒB è¡¨ä¸­å«æœ‰åŸè¡¨ä¸­ä½åºä¸ºå¶æ•°çš„ç»“ç‚¹ï¼Œä¸”ä¿æŒç»“ç‚¹é—´ç›¸å¯¹é¡ºåºä¸å˜ï¼Œæœ€åè¿”å› B è¡¨ï¼Œ

```c
LinkList Reverse(LinkList &L){
    if(L->next = NULL){
        return NULL;
    }
    LinkList B = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next;
    LNode *ra = A,*rb = B;
    while(p != NULL){
        ra->next = p;
        ra = p;
        p = p->next;
        if(p != NULL){ // å•é“¾è¡¨å¥‡æ•°æˆ–å¶æ•°
            rb->next = p;
            rb = p;
            p = p->next;
        }
    }
    ra->next = NULL; // å°¾æŒ‡é’ˆç½®ç©º
    rb->next = NULL;
}
```

### 2.10. ç¼–å†™ç®—æ³•å°†ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ A ={a1, b1, a2, b2,..., an, bn}åˆ†è§£ä¸ºä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ A å’Œ B ä½¿å¾— A ={a1, a2,â€¦, an}, B ={bn,â€¦, b2, b1}, åŸ A è¡¨ä¸­ç»“ç‚¹ä¸ªæ•°ä¸ä¸€å®šä¸ºå¶æ•°ã€‚

```c
// å¯¹Aä½¿ç”¨å°¾æ’æ³•(æ­£åº),å¯¹Bä½¿ç”¨å¤´æ’æ³•(é€†åº)
LinkList Split(LinkList A){
    if(A->next == NULL){
        return NULL;
    }
    LinkList B = (LNode *)malloc(sizeof(LNode));
    B->next = NULL;
    LNode *p = A->next,*r = A,*q;
    while(p != NULL){
        r->next = p;
        r = p;
        p = p->next;
        while(p != NULL){
            q = p->next; // é˜²æ–­é“¾æŒ‡é’ˆ
            p->next = B->next;
            B->next = p;
            p = q;
        }
    }
    r->next = NULL;
    return B;
}
```

### 2.11. å°†ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L åˆ†è§£ä¸ºä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ A å’Œ B, ä½¿å¾— A è¡¨ä¸­å«æœ‰åŸè¡¨ä¸­æ•°æ®åŸŸä¸ºå¥‡æ•°çš„ç»“ç‚¹ï¼Œè€Œ B è¡¨ä¸­å«æœ‰åŸè¡¨ä¸­æ•°æ®åŸŸä¸ºå¶æ•°çš„ç»“ç‚¹ï¼Œä¸”ä¿æŒç›¸å¯¹é¡ºåºä¸å˜ï¼Œæœ€ååˆ é™¤å•é“¾è¡¨ L çš„å¤´ç»“ç‚¹ã€‚

```c
void Split(LinkList L,LinkList &A,LinkList &B){
    if(L->next == NULL){
        return;
    }
    // åˆ†é…ç©ºé—´
    A = (LinkList)malloc(sizeof(LNode));
    B = (LinkList)malloc(sizeof(LNode));
    // å®šä¹‰æŒ‡é’ˆ
    LNode *p = L->next,*ra = A,*rb = B;
    while(p != NULL){
        if(p->data % 2 != 0){
            ra->next = p;
            ra = p;
        }else{
            rb->next = p;
            rb = p;
        }
        p = p->next;
    }
    ra->next = NULL;
    rb->next = NULL;
    free(L);
}
```

### 2.12. æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹å•é“¾è¡¨ Lï¼ŒL ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ é™¤é“¾è¡¨ L ä¸­çš„æœ€å°å€¼ç»“ç‚¹ã€‚

```c
void Del_Min(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *minpre = L,*minp = L->next;
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
}
```

### 2.13. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L ä¸­åˆ é™¤æ‰€æœ‰å€¼ä¸º x çš„ç»“ç‚¹ï¼Œå¹¶é‡Šæ”¾å…¶ç©ºé—´ã€‚

```c
void Del_x(LinkList L, int x){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L,p = L->next;
    while(p != NULL){
        if(p->data = x){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 2.14. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L ä¸­åˆ é™¤æ‰€æœ‰æ•°æ®åŸŸçš„å€¼ä»‹äºç»™å®šçš„ä¸¤ä¸ªå€¼ä¹‹é—´çš„ç»“ç‚¹ï¼Œå¹¶é‡Šæ”¾å…¶ç©ºé—´ã€‚

```c
void Del_min_max(LinkList L,int min,int max){
    if(L->next == NULL || min >= max){
        return;
    }
    LNode *pre = L,*p = L->next;
    while(p != NULL){
        if(p->data >= min && p->data <= max){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 2.15. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨å¸¦å¤´ç»“ç‚¹çš„éé€’å‡æœ‰åºå•é“¾è¡¨ L ä¸­åˆ é™¤æ‰€æœ‰å€¼é‡å¤çš„ç»“ç‚¹ï¼Œä½¿å€¼é‡å¤çš„ç»“ç‚¹åªä¿ç•™ä¸€ä¸ªã€‚

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *pre = L->next,*p = pre->next;
    while(p != NULL){
        if(pre->data == p->data){
            pre->next = p->next;
            free(p);
            p = pre->next;
        }else{
            pre = p;
            p = p->next;
        }
    }
}
```

### 2.16. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåœ¨å¸¦å¤´ç»“ç‚¹çš„æ— åºå•é“¾è¡¨ L ä¸­åˆ é™¤æ‰€æœ‰å€¼é‡å¤çš„ç»“ç‚¹ï¼Œä½¿å€¼é‡å¤çš„ç»“ç‚¹åªä¿ç•™ä¸€ä¸ª

```c
void Del_Same(LinkList L){
    if(L->next == NULL){
        return;
    }
    LNode *r = L->next;
    LNode *pre,*p;
    while(r!=NULL){
        pre = r; // æ¯æ¬¡r=r->nextéƒ½ä¼šå¯¹på’Œpreèµ‹å€¼
        p = r->next;
        while(p!=NULL){
            if(p->data == r->data){
                pre->next = p->next;
                free(p);
                p = pre->next;
            }else{
                pre = p;
                p = p->next;
            }
        }
        r = r->next;
    }
}
```

### 2.17. è®¾ A å’Œ B æ˜¯ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„é€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å•é“¾è¡¨ A ä¸ B çš„äº¤é›†ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªæ–°çš„å•é“¾è¡¨ C, è¦æ±‚ä¸ç ´å Aã€B çš„ç»“ç‚¹ã€‚

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LinkList C = (LinkList)malloc(sizeof(LNode));
    LNode *p = A->next,*q = B->next,*r = C; // éå†æŒ‡é’ˆ
    LNode *s; // å­˜ç»“ç‚¹
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            q = q->next;
        }else if(p->data < q->data){
            p = p->next;
        }else{
            s->data = p->data;
            r->next = s;
            r = r->next;
            p = p->next;
            q = q->next;
        }
    }
    r->next = NULL;
    return C;
}
```

### 2.18. è®¾ A å’Œ B æ˜¯ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„é€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å•é“¾è¡¨ A ä¸ B çš„äº¤é›†ï¼Œå¹¶å­˜æ”¾äº A é“¾è¡¨ä¸­ï¼Œå…¶å®ƒç»“ç‚¹å‡é‡Šæ”¾å…¶ç©ºé—´ã€‚

```c
LinkList Union_Same(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else if(p->data < q->data){
            u = p->next;
            free(p);
            p = u;
        }else{
            r->next = p;
            p = p->next;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p != NULL){
        u = p->next;
        free(p);
        p = u;
    }
    while(q != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL; // å°¾æŒ‡é’ˆç½®ç©º
    free(B); // é‡Šæ”¾å¤´ç»“ç‚¹
    return A;
}
```

### 2.19. è®¾ A å’Œ B æ˜¯ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„é€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°† A å’Œ B ä¸¤ä¸ªå•é“¾è¡¨å½’å¹¶ä¸ºä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„éé€’å‡æœ‰åºå•ç–‘è¡¨ï¼Œè¦æ±‚åˆ©ç”¨åŸæ¥ä¸¤ä¸ªå•é“¾è¡¨çš„ç»“ç‚¹ç»„æˆå½’å¹¶åçš„å•é“¾è¡¨ã€‚

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL &&ã€€ï¼¢->next = NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    while(p != NULL && q != NULL){
        if(p.data >= q.data){
            r->next = q;
            r = q;
            q = q->next;
        }else{
            r->next = p;
            r = p;
            p = p->next;
        }
    }
    while(p->next != NULL){
        r->next = p;
        r = p;
        p = p->next;
    }
    while(q->next != NULL){
        r->next = q;
        r = q;
        q = q->next;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 2.20. è®¾ A å’Œ B æ˜¯ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„é€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°† A å’Œ B ä¸¤ä¸ªå•é“¾è¡¨å½’å¹¶ä¸ºä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„éé€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¦æ±‚åˆ©ç”¨åŸæ¥ä¸¤ä¸ªå•é“¾è¡¨çš„ç»“ç‚¹ç»„æˆå½’å¹¶åçš„å•é“¾è¡¨ã€‚

```c
LinkList Merge(LinkList A,LinkList B){
    if(A->next == NULL && B->next ==NULL){
        return;
    }
    LNode *p = A->next,*q = B->next,*r;
    A->next = NULL;
    while(p != NULL && q != NULL){
        if(p->data >= q->data){
            r = q->next;
            q->next = A->next;
            A->next = q;
            q = r;
        }else{
            r = p->next;
            p->next = A->next;
            A->next = p;
            p = r;
        }
    }
    while(p->next != NULL){
        r = p->next;
        p->next = A->next;
        A->next = p;
        p = r;
    }
    while(q->next != NULL){
        r = q->next;
        q->next = A->next;
        A->next = q;
        q = r;
    }
    free(B);
    return A;
}
```

### 2.21. è®¾ A å’Œ B æ˜¯ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„é€’å¢æœ‰åºå•é“¾è¡¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å•é“¾è¡¨ A ä¸ B çš„å·®é›†ï¼Œå¹¶è¿”å›å·®é›†é“¾è¡¨ã€‚é“¾è¡¨ A ä¸ B çš„å·®é›†å®šä¹‰ä¸ºï¼šåœ¨é“¾è¡¨ A ä¸­å­˜åœ¨ä½†ä¸åœ¨é“¾è¡¨ B ä¸­å­˜åœ¨çš„æ‰€æœ‰ç»“ç‚¹çš„é›†åˆã€‚è¦æ±‚åˆ©ç”¨åŸæ¥ä¸¤ä¸ªå•é“¾è¡¨çš„ç»“ç‚¹ç»„æˆå·®é›†é“¾è¡¨ï¼Œå…¶å®ƒç»“ç‚¹å‡é‡Šæ”¾å…¶ç©ºé—´ã€‚

```c
LinkList Diff(LinkList A,LinkList B){
    if(A->next == NULL || B->next == NULL){
        return NULL;
    }
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data < q->data){
            r->next = p;
            p = p->next;
        }else if(p->data > q->data){
            u = q->next;
            free(q);
            q = u;
        }else{
            u = p->next;
            free(p);
            p = u;
            u = q->next;
            free(q);
            q = u;
        }
    }
    while(p->next != NULL){
        r->next = p;
        p = p->next;
    }
    while(q->next != NULL){
        u = q->next;
        free(q);
        q = u;
    }
    r->next = NULL;
    free(B);
    return A;
}
```

### 2.22. ä¸¤ä¸ªæ•´æ•°åºåˆ— A ={a1, a2, a3,â€¦, am}å’Œ B ={b1, b2, b3,â€¦, bn}å·²ç»å­˜å…¥ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­åºåˆ— B æ˜¯å¦æ˜¯åºåˆ— A çš„è¿ç»­å­åºåˆ—ã€‚

```c
bool Pattern(LinkList A,LinkList B){
    LNode *p = A->next,*q = B->next,*r = A;
    LNode *u;
    while(p != NULL && q != NULL){
        if(p->data == q->data){
            p = p->next;
            q = q->next;
        }else{
            pre = pre->next;
            p = pre;
            q = B->next;
        }
    }
    if(q == NULL){
        return true;
    }else{
        return false;
    }
}
```

### 2.23. é€šå¸¸å•é“¾è¡¨å°¾ç»“ç‚¹æŒ‡é’ˆåŸŸä¸º NULL, è€Œå•é“¾è¡¨æœ‰ç¯ï¼Œæ˜¯æŒ‡å•é“¾è¡¨æœ€åä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆæŒ‡å‘äº†é“¾è¡¨ä¸­çš„æŸä¸ªç»“ç‚¹ã€‚è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L æ˜¯å¦æœ‰ç¯ï¼Œå¦‚æœæœ‰ç¯ï¼Œè¿”å›ç¯çš„å…¥å£ç»“ç‚¹ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œè¿”å› NULLã€‚

```c
// æœ‰ç¯æ— ç¯:å¿«æ…¢æŒ‡é’ˆé—®é¢˜    æ‰¾åˆ°ç›¸é‡ç‚¹:æ•°å­¦é—®é¢˜ -> a=nr-x
LinkList FindLoop(LinkList L){
    if(L->next == NULL){
        return NULL;
    }
    LNode *slow = L,*fast = L;
    while(fast != NULL || fast->next != NULL){
        if(fast != slow){
            fast = fast->next->next;
            slow = slow->next;
        }else{
            break;
        }
    }
    LNode *p = L;
    LNode *q = slow;
    while(p != q){
        p = p->next;
        q = q->next;
    }
    return p;
}
```

### 2.24. æœ‰ä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„éç©ºå¾ªç¯å•é“¾è¡¨ h1 å’Œ h2, è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†é“¾è¡¨ h2 é“¾æ¥åˆ°é“¾è¡¨ h1 ä¹‹åï¼Œè¦æ±‚é“¾æ¥åçš„é“¾è¡¨ä»æ˜¯ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å¾ªç¯å•é“¾è¡¨ã€‚

```c
LinkList Link(LinkList h1,LinkList h2){
    LNode *p = h1->next,*q = h2->next;
    while(p->next != h1){
        p = p->next;
    }
    while(q->next != h2){
        q = q->next;
    }
    p->next = h2->next;
    q->next = h1;
    free(h2);
}
```

### 2.25. æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å¾ªç¯å•é“¾è¡¨ L, é“¾è¡¨ L ä¸­å«æœ‰ä¸‰ç±»å­—ç¬¦çš„æ•°æ®å…ƒç´ ï¼ˆå¦‚ï¼šå­—æ¯å­—ç¬¦ã€æ•°å­—å­—ç¬¦å’Œå…¶å®ƒå­—ç¬¦)ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†é“¾è¡¨æ‹†åˆ†ä¸ºä¸‰ä¸ªä¸å¸¦å¤´ç»“ç‚¹çš„å¾ªç¯å•é“¾è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªå¾ªç¯å•é“¾è¡¨å‡åªå«ä¸€ç±»å­—ç¬¦ã€‚

```c
void Split(LinkList L, LinkList &A, LinkList &B, LinkList &C){
    A = (LinkList)malloc(sizeof(LNode));
    B = (LinkList)malloc(sizeof(LNode));
    C = (LinkList)malloc(sizeof(LNode));
    LNode *p = L->next,*ra = A,*rb = B,*rc = C;
    while(p->next != L){
        if(p->data > 'a' && p->data < 'z' || p->data > 'A' && p->data < 'Z'){
            ra->next = p;
            ra = ra->next;
        }else if(p->data > '0' && p->data < '9'){
            rb->next = p;
            rb = rb->next;
        }else{
            rc->next = p;
            rc = rc->next;
        }
        p = p->next;
    }
    ra->next = A;
    rb->next = B;
    rc->next = C;
    free(L);
}
```

### 2.26. æœ‰ä¸€ä¸ªä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L, L ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ é™¤é“¾è¡¨ L ä¸­çš„æœ€å°å€¼ç»“ç‚¹ã€‚

æ³•ä¸€:

```c
void Del_Min(LinkList &L){
    if(L == NULL){
        return;
    }
    LNode *pre,*p = L;
    LNode *premin,*minp = L;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    if(minp == L){
        L = L->next;
        free(minp);
    }else{
        minpre->next = minp->next;
        free(minp);
    }
}
```

æ³•äºŒ:

```c
void Del_Min(LinkList &L){
    if(L == NULL){
    	return;
    }
    LinkList head = (LinkList)malloc(sizeof(LNode));
    head->next = L;
    LNode *p = L,*pre = head;
    LNode *minp = p,*premin = pre;
    while(p != NULL){
        if(p->data <= minp->data){
            minp = p;
            minpre = pre;
        }
        pre = p;
        p = p->next;
    }
    minpre->next = minp->next;
    free(minp);
    L = head->next;
    free(head);
}
```

### 2.27. è®¾å°† n(n > 1)ä¸ªæ•´æ•°å­˜æ”¾åˆ°ä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L ä¸­ï¼Œè®¾è®¡ç®—æ³•å°† L ä¸­ä¿å­˜çš„åºåˆ—å¾ªç¯å³ç§» k(0 < k < n)ä¸ªä½ç½®ã€‚ä¾‹å¦‚ï¼Œè‹¥ k = 1, åˆ™å°†é“¾è¡¨{0,1,2,3}å˜ä¸º{3,0,1,2}ã€‚

```c
LinkList Move_k(LinkList L,int k){
    LNode *p = L;
    int len = 1;
    while(p->next != NULL){
        p = p->next;
        len++;
    }
    p->next = L;
    for(int i = 0;i < len-k;i++){
        p = p->next;
    }
    L = p->next;
    p->next = NULL;
    return L;
}
```

### 2.28. è®¾æœ‰ä¸€ä¸ªä¸å¸¦å¤´ç»“ç‚¹çš„é•¿åº¦ä¸º(n ä¸ºå¶æ•°)çš„éç©ºå•é“¾è¡¨ï¼Œä¸”ç»“ç‚¹å€¼éƒ½å¤§äº 0ï¼Œè®¾è®¡ç®—æ³•æ±‚è¿™ä¸ªå•é“¾è¡¨çš„æœ€å¤§å­ªç”Ÿå’Œã€‚å­ªç”Ÿå’Œå®šä¹‰ä¸ºäºŒä¸ªç»“ç‚¹å€¼ä¸å…¶å­ªç”Ÿç»“ç‚¹å€¼ä¹‹å’Œï¼Œå¯¹äºç¬¬ i ä¸ªç»“ç‚¹ï¼ˆä» 0 å¼€å§‹ï¼‰å…¶å­ªç”Ÿç»“ç‚¹ä¸ºç¬¬ n-i-1 ä¸ªç»“ç‚¹ã€‚

```c
// å¿«æ…¢æŒ‡é’ˆæ³•
int Sum_Max(LinkList L){
    LNode *slow = L,*fast = L;
    while(fast->next != NULL){
        slow = slow->next;
        fast = fast->next->next;
    }
    // å°†ååŠéƒ¨åˆ†é€†ç½®
    LNode *p = slow->next,*q; // qæ˜¯é˜²æ–­é“¾æŒ‡é’ˆ
    slow->next = NULL;
    while(q != NULL){
        q = p->next;
        p->next = slow->next;
        slow->next = p;
    }
    p = L;
    q = slow->next;
    int max = p->data + q->data;
    while(q != NULL){
        if((p->data + q->data) > max){
            max = p->data + q->data;
        }
        p = p->next;
        q = q->next;
    }
    return max;
}
```

### 2.29. (çº¦ç‘Ÿå¤«ç¯)æœ‰ n ä¸ªäººå›´æˆä¸€ä¸ªåœˆï¼Œä»–ä»¬çš„ç¼–å·ä¸º 1~nã€‚ç°åœ¨è¦æ±‚ä»ç¬¬ 1 ä¸ªäººå¼€å§‹æŠ¥æ•°ï¼Œæ•°åˆ° m çš„äººå‡ºåˆ—ï¼Œå‡ºåˆ—åçš„ä¸‹ä¸€ä¸ªäººç»§ç»­ä» 1 å¼€å§‹æŠ¥æ•°ï¼ŒåŒæ ·æ•°åˆ° m çš„äººå‡ºåˆ—ï¼Œä¸€ç›´é‡å¤æ­¤è¿‡ç¨‹ï¼Œç›´åˆ°åœˆä¸­åªå‰©ä¸‹æœ€åä¸€ä¸ªäººï¼Œè¿”å›å…¶ç¼–å·ã€‚

```c
int Joesphus(LinkList L,int m){
    // åˆå§‹åŒ–æŒ‡é’ˆ
    LNode *p = L,*q = L;
    while(q->next != L){
        q = q->next;
    }
    while(p->next != p){
        for(int i = 1; i < m; i++){
            pre = p;
            p = p->next;
        }
        pre->next = p->next;
        free(p);
        p = pre->next;
    }
    return p->data;
}
```

### 2.30. åŒé“¾è¡¨çš„ç»“æ„ä½“å®šä¹‰ã€‚

```c
typedef struct DNode{
    int data;
    struct DNode *prior,*next;
} DNode, *DLinkList;
```

### 2.31. åœ¨ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„éé€’å‡æœ‰åºåŒé“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªå€¼ä¸º x çš„æ–°ç»“ç‚¹ï¼Œä½¿å¾—æ’å…¥æ–°ç»“ç‚¹åé“¾è¡¨ä¾ç„¶éé€’å‡æœ‰åºã€‚

```c
void ListInsert(LinkList L, int x){
    DNode *p = L->next,*pre = L;
    while(p->data < x){
        pre = p;
        p = p->next;
    }
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = x;
    s->prior = pre;
    pre->next = s;
    s->next = p;
    if(p != NULL){ // æ–°æ’å…¥çš„ç»“ç‚¹åé¢å¯èƒ½ä¸ºç©º
        p->prior = s;
    }
}
```

### 2.32. æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„åŒé“¾è¡¨ L, L ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ é™¤é“¾è¡¨ L ä¸­çš„æœ€å°å€¼ç»“ç‚¹ã€‚

```c
void Del_Min(DLinkList L){
    DNode *p = L->next,*pre = L;
    DNode *minp = L->next,*minpre = L;
    while(p != NULL){
        if(p->data < minp->data){
            minp = p;
        }
        pre = p;
        p->next;
    }
    minpre->next = minp->next;
    if(minp->next != NULL){
        minp->next->prior = minpre;
    }
    free(minp);
}
```

### 2.33. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­å¸¦å¤´ç»“ç‚¹çš„å¾ªç¯åŒé“¾è¡¨ L æ˜¯å¦å¯¹ç§°

```c
bool Asymmetries(DLinkList L){
    if(L->next == L || L->next->next == L){
        return false;
    }
    DNode *p = L->next,*q = L->prior;
    while(p != q && q->next != p){
        if(p->data == q->data){
            p = p->next;
            q = q->next;
        }else{
            return false;
        }
    }
    return true;
}
```

### 2.34. æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„åŒé“¾è¡¨ L, L ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå°†é“¾è¡¨ L ä¸­çš„æœ€å¤§å€¼ç»“ç‚¹ç§»åŠ¨åˆ°æœ€å‰é¢ã€‚

```c
void Move_Max(DLinkList L){
    if(L->next == NULL){
        return;
    }
    DNode *pre = L,*p = L->next;
    DNode *maxp = p,*maxpre = pre;
    while(p != NULL){
        if(p->data > maxp->data){
            maxp = p;
            maxpre = pre;
        }
        pre = p
        p = p->next;
    }
    DNode q = L->next;
    if(maxp = q){
        return;
    }
    maxpre->next = maxp->next;
    if(maxp->next != NULL){
        maxp->next->prior = maxpre;
    }
    maxp->prior = L;
    L->next = maxp;
    maxp->next = q;
    q->prior = maxp;
}
```

### 2.35. è®¾æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„éå¾ªç¯åŒé“¾è¡¨ L, å…¶æ¯ä¸ªç»“ç‚¹é™¤äº†æœ‰ priorã€data å’Œ next åŸŸå¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªè®¿é—®é¢‘åº¦åŸŸ freq, å…¶å€¼å‡åˆå§‹åŒ–ä¸º 0ã€‚L ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œæ¯å½“åœ¨é“¾è¡¨ä¸­æ‰§è¡Œä¸€æ¬¡ Locate(L, x)è¿ç®—æ—¶ï¼Œä»¤å€¼ä¸º x çš„ç»“ç‚¹ä¸­ freq åŸŸçš„å€¼å¢ 1ï¼Œå¹¶ä½¿æ­¤é“¾è¡¨ä¸­çš„ç»“ç‚¹ä¿æŒæŒ‰è®¿é—®é¢‘åº¦é€’å‡çš„é¡ºåºæ’åˆ—ï¼Œä¸”æœ€è¿‘è®¿é—®çš„ç»“ç‚¹æ’åœ¨é¢‘åº¦ç›¸åŒçš„ç»“ç‚¹ä¹‹å‰ï¼Œä»¥ä¾¿ä½¿é¢‘ç¹è®¿é—®çš„ç»“ç‚¹æ€»æ˜¯é è¿‘è¡¨å¤´ã€‚è¯•ç¼–å†™ç¬¦åˆä¸Šè¿°è¦æ±‚çš„ Locate(L, x)å‡½æ•°ï¼Œè¿”å›æ‰¾åˆ°ç»“ç‚¹çš„åœ°å€ï¼Œç±»å‹ä¸ºæŒ‡é’ˆå‹ã€‚

```c
DNode Locate(DLinkList L, int x){
    if(L->next == NULL){
        return NULL;
    }
    DNode *p = L->next,*pre = L;
    while(p != NULL){
        if(p->data == x){
            break;
        }
        pre = p;
        p = p->next;
    }
    if(p->prior->data = p->data || p->prior = L){
        return p;
    }
    pre->next = p->next;
    if(p->next != NULL){
        p->next->prior = pre;
    }
    DNode q = L->next;
    pre = L;
    while(q->data > p->data){
        pre = q;
        q = q->next;
    }
    p->prior = pre;
    pre->next = p;
    p->next = q;
    q->prior = p;
    return p;
}
```

### 2.36. æœ‰ä¸€ä¸ªä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L, L ä¸­å„ä¸ªç»“ç‚¹çš„å€¼éƒ½ä¸ç›¸åŒï¼Œè¯·è®¾è®¡ä¸€ä¸ªé€’å½’ç®—æ³•ï¼ŒæŸ¥æ‰¾é“¾è¡¨ L ä¸­çš„æœ€å°å€¼ç»“ç‚¹ã€‚

```c
DNode *Find_Min(DNodeList L){
    if(L == NULL || L->next == NULL){
        return L;
    }
    DNode *p = Find_Min(L->next);
    if(p->data > L){
        return L;
    }{
        return p;
    }
}
```

### 2.37. æ ˆçš„ç»“æ„ä½“å®šä¹‰åŠåŸºæœ¬æ“ä½œã€‚

```c
#define MaxSize 50
typedef struct{
    int data[MaxSize];
    int top;
} Stack;

void InitStack(Stack &S){
    S.top = -1;
}
```

## 3. æ ˆå’Œé˜Ÿåˆ—

### 3.1. æœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ L, ç»“ç‚¹ç»“æ„ç”± data å’Œ next ä¸¤ä¸ªåŸŸæ„æˆï¼Œå…¶ä¸­ data åŸŸä¸ºå­—ç¬¦å‹ã€‚è¯•è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ¤æ–­è¯¥é“¾è¡¨çš„å…¨éƒ¨ n ä¸ªå­—ç¬¦æ˜¯å¦ä¸­å¿ƒå¯¹ç§°ã€‚ä¾‹å¦‚ï¼šxyxã€yyx éƒ½æ˜¯ä¸­å¿ƒå¯¹ç§°ã€‚

```c
int Func(LinkList L,int x){
    char s[n/2];
    LNode *p = L->next;
    int i;
    for(i = 0;i < n/2; i++){
        s[i] = p->next;
    }
    if(n % 2 == 1){
        p = p->next;
    }
    while( p != NULL){
        if(p->data != s[i].data){
            return 0;
        }
        p = p->next;
        i--;
    }
    return 1;
}
```

### 3.2. å‡è®¾ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼ä¸­åŒ…å«å°æ‹¬å·å’Œä¸­æ‹¬å· 2 ç§ç±»å‹çš„æ‹¬å·ï¼Œç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤åˆ«è¡¨è¾¾å¼ä¸­çš„æ‹¬å·æ˜¯å¦é…å¯¹ï¼Œå‡è®¾ç®—æœ¯è¡¨è¾¾å¼å­˜æ”¾äºå­—ç¬¦æ•°ç»„ä¸­ï¼Œä»¥å­—ç¬¦â€œ\0â€ä½œä¸ºç®—æœ¯è¡¨è¾¾å¼çš„ç»“æŸç¬¦ã€‚

```c
int BracketCheck(char a[]){
    Stack S;
    InitStack(S);
    char x;
    for(int i,a[i] != '\n', i++){
        switch(a[i]){
            case '(':
                Push(S, a[i]);
                break;
            case '[':
                Push(S,a[i]);
                break;
            case ')':
                if(IsEmpty(S)) return 0; // æ¯æ¬¡å‡ºæ ˆä¹‹å‰è®°å¾—åˆ¤ç©º
                Pop(S, x);
                break;
            case ']':
                if(IsEmpty(S)) return 0;
                Pop(S, x);
                break;
            default:
                break;
        }
    }
    if(IsEmpty(S)){
        return 1;
    }else{
        return 0;
    }
}
```

### 3.3. æœ‰ä¸¤ä¸ªæ ˆ s1ã€s2 éƒ½é‡‡ç”¨é¡ºåºæ ˆæ–¹å¼ï¼Œå¹¶å…±äº«ä¸€ä¸ªå­˜å‚¨åŒº [0ï¼Œ...ï¼Œmaxsize-1], ä¸ºäº†å°½é‡åˆ©ç”¨ç©ºé—´ï¼Œå‡å°‘æº¢å‡ºçš„å¯èƒ½ï¼Œå¯é‡‡ç”¨æ ˆé¡¶ç›¸å‘ã€è¿é¢å¢é•¿çš„å­˜å‚¨æ–¹å¼ã€‚è¯•è®¾è®¡å†™å‡ºæ­¤æ ˆçš„å®šä¹‰å’Œ s1ã€s2 æœ‰å…³å…¥æ ˆå’Œå‡ºæ ˆçš„æ“ä½œç®—æ³•ã€‚

```c
// å…±äº«æ ˆ
#define MaxSize 50
typedef struct {
    int data[MaxSize];
    int top[2];
} Stack;
Stack s;
s.top[0] = -1;
s.top[1] = MaxSize;

int Push(int i, int x){
    if(i > 1 || i < 0){
        return 0;
    }
    if(s.top[1] - s.top[0] == 1){
        return 0;
    }
    switch(i){
        case 0:
            s.top[0]++;
            s.data[s.top[0]] = x;
            break;
        case 1:
            s.top[1]--;
            s.data[s.top[1]] = x;
            break;
    }
    return 1;
}

int Pop(int i, int x){
    if(i > 1 || i < 0){
        return 0;
    }
    switch(i){
        case 0:
            if(s.top[0] == -1){
                return 0;
            }else{
                x = s.data[s.top[0]--];
            }
            break;
        case 1:
            if(s.top[1] == MaxSize){
                return 0;
            }else{
                x = s.data[s.top[1]++];
            }
    }
    return 1;
}
```

### 3.4. é˜Ÿåˆ—çš„ç»“æ„ä½“å®šä¹‰ä¸åŸºæœ¬æ“ä½œ

```c
#define MaxSize 50
typedef struct{
    int data[MaxSize];
    int front,rear;
} Queue;

void InitQueue(Queue &Q){
    if(Q.front == Q.rear){
        return 1;
    }
    return 0;
}

int EnQueue(Queue &Q,int x){
    if(Q.rear == MaxSize){
        return 0;
    }
    Q.data[Q.rear] = x;
    Q.rear++;
    return 1;
}

int DeQueue(Queue &Q,int x){
    if(Q.rear == Q.front){
        return 0;
    }
    x = Q.data[Q.front];
    Q.front++;
    return 1;
}

// å¾ªç¯é˜Ÿåˆ—
Q.front == Q.rear; // åˆ¤ç©º
Q.front == (Q.rear+1) % MaxSize; // åˆ¤æ»¡

int EnQueue(Queue &Q,int x){
    if((Q.rear + 1) % MaxSize == Q.front){
        return 0;
    }
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;
    return 1;
}

int DeQueue(Queue &Q,int x){
    if(Q.rear == Q.front){
        return 0;
    }
    x = Q.data[Q.front];
    Q.front = (Q.front+1) % MaxSize;
    return 1;
}
```

### 3.5. è‹¥å¸Œæœ›å¾ªç¯é˜Ÿåˆ—ä¸­çš„å…ƒç´ éƒ½èƒ½å¾—åˆ°åˆ©ç”¨ï¼Œåˆ™éœ€è®¾ç½®ä¸€ä¸ªæ ‡å¿—åŸŸ tag, å¹¶ä»¥ tag çš„å€¼ä¸º 0 æˆ– 1 æ¥åŒºåˆ†é˜Ÿå¤´æŒ‡é’ˆ front å’Œé˜Ÿå°¾æŒ‡é’ˆ rear ç›¸åŒæ—¶çš„é˜Ÿåˆ—çŠ¶æ€æ˜¯ "ç©º" è¿˜æ˜¯ "æ»¡"ã€‚è¯•ç¼–å†™ä¸æ­¤ç»“æ„ç›¸åº”çš„å…¥é˜Ÿå’Œå‡ºé˜Ÿç®—æ³•ã€‚

```c
// ä»…éœ€åœ¨ç»“æ„ä½“é‡Œå¤šåŠ ä¸€ä¸ªtagä½
// å½“å…¥é˜Ÿæ—¶åˆ¤æ–­tag,å½“tag == 1 && Q.rear == Q.front return 0; ç»“æŸå…¥é˜Ÿtag = 1
// å½“å‡ºé˜Ÿæ—¶åˆ¤æ–­tag,å½“tag == 0 && Q.rear == Q.front return 0; ç»“æŸå‡ºé˜Ÿtag = 0
```

### 3.6. Q æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼ŒS æ˜¯ä¸€ä¸ªç©ºæ ˆï¼Œå®ç°å°†é˜Ÿåˆ—ä¸­çš„å…ƒç´ é€†ç½®çš„ç®—æ³•ã€‚

```c
void Reverse(Queue &Q, Stack S){
    int x;
    while(!IsEmpty(Q)){
        DeQueue(Q,x);
        Push(S,x);
    }
    while(!Empty(S)){
        Pop(S,x);
        EnQueue(Q,x);
    }
}
```

## 4. æ ‘

### 4.1. åˆ©ç”¨é€’å½’æ±‚è§£ n çš„é˜¶ä¹˜

```c
int Func(int n){
    if(n == 0){
        return 1;
    }
    return n * Func(n-1);
}
```

### 4.2. æ–æ³¢é‚£å¥‘æ•°åˆ—æ˜¯æ»¡è¶³ F(0)= 1, F(1)= 1, F(n)= F(n-1)+F(n-2)(nâ‰¥2)çš„æ•°åˆ—ï¼Œæ•°åˆ—çš„å‰å‡ é¡¹ä¸º 1,1,2,3ï¼Œ 5,8,13,21,â€¦ã€‚å†™å‡ºæ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬ n é¡¹çš„ç¨‹åºã€‚

```c
int Func(int n){
    if(n == 0 || n == 1){
        return 1;
    }
    return Func(n-1) + Func(n-2);
}
```

### 4.3. äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æ„ä½“å®šä¹‰

```c
typedef struct BiTNode{
    int data;
    struct BitNode *lchild,*rchild;
} BiTNode, *BiTree;
```

### 4.4. è¯·åˆ†åˆ«å†™å‡ºäºŒå‰æ ‘çš„å…ˆåº, ä¸­åºå’Œååºé€’å½’éå†ç®—æ³•ã€‚

```c
// ä»¥å…ˆåºä¸ºä¾‹
void PreOrder(BiTree T){
    if(T == NULL) return;
    printf("%d", T->data);
    PreOrder(T->lchild);
    PreOrder(T->rchild);
}
```

### 4.5. åœ¨ä¸€æ£µä»¥äºŒå‰é“¾è¡¨ä¸ºå­˜å‚¨ç»“æ„çš„äºŒå‰æ ‘ä¸­ï¼ŒæŸ¥æ‰¾ data åŸŸå€¼ç­‰äº key çš„ç»“ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™å°†æŒ‡é’ˆ q æŒ‡å‘è¯¥ç»“ç‚¹ï¼Œå‡è®¾ data ä¸º int å‹ã€‚ï¼ˆäºŒå‰æ ‘ä¸­ç»“ç‚¹å€¼éƒ½ä¸ç›¸åŒï¼‰

```c
void Search(BiTree T,BNode *&q,int key){
    if(T == NULL) return;
    if(T->data == key){
        q = T;
    }else{
        Search(T->lchild, q, key);
        Search(T->rchild, q, key);
    }
}
```

### 4.6. å‡è®¾äºŒå‰æ ‘é‡‡ç”¨äºŒå‰é“¾è¡¨å½¢å¼å­˜å‚¨ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å…ˆåºéå†åºåˆ—ä¸­ç¬¬ k(1â‰¤kâ‰¤ äºŒå‰æ ‘ä¸­ç»“ç‚¹ä¸ªæ•°)ä¸ªç»“ç‚¹çš„å€¼ã€‚

```c
int n; // å®šä¹‰æˆå…¨å±€å˜é‡
void Search_k(BiTree T, int k){
    if(T == NULL) return;
    n++;
    if(n == k){
        printf("%d", T->data);
    }
    Search_k(T->lchild,k);
    Search_k(T->rchild,k);
}
```

### 4.7. åˆ©ç”¨é€’å½’è®¡ç®—äºŒå‰æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„ä¸ªæ•°.

::: code-group

```c [æ³•ä¸€]
// æ³•ä¸€:
int n = 0;
void Count(BiTree T){
    if(T == NULL) return;
    n++;
    Count(T->lchild);
    Count(T->rchild);
}
```

```c [æ³•äºŒ]
// æ³•äºŒ:
int Count(BiTree T){
    if(T == NULL) return 0;
    int n1 = Count(T->lchild); // å±€éƒ¨å˜é‡çš„ä½¿ç”¨ å¶å­ç»“ç‚¹è¿”å› 1
    int n2 = Count(T->rchild);
    return n1 + n2 + 1;
}
```

:::

### 4.8. åˆ©ç”¨é€’å½’è®¡ç®—äºŒå‰æ ‘ä¸­æ‰€æœ‰å¶å­ç»“ç‚¹çš„ä¸ªæ•°.

```c
// æ³•äºŒ
int Count(BiTree T){
    int n1,n2;
    if(T == NULL) return;
    if(T->lchild == NULL && T->rchild == NULL){
        return 1;
    }else{
        n1 = Count(T->lchild);
        n2 = Count(T->rchild);
        return n1 + n2;
    }
}
```

### 4.9. åˆ©ç”¨é€’å½’è®¡ç®—äºŒå‰æ ‘ä¸­æ‰€æœ‰åŒåˆ†æ”¯ç»“ç‚¹ä¸ªæ•°

```c
int Count(BiTree T){
    int n1,n2;
    if(T == NULL) return;
    n1 = Count(T->lchild);
    n2 = Count(T->rchild);
    if(T->lchild && T->rchild){
        return 1 + n1 + n2;
    }else{
        return n1 + n2;
    }
}
```

### 4.10. åˆ©ç”¨é€’å½’è®¡ç®—äºŒå‰æ ‘ä¸­æ‰€æœ‰å•åˆ†æ”¯ç»“ç‚¹ä¸ªæ•°

```c
int Count(BiTree T){
    int n1,n2;
    if(T == NULL) return;
    n1 = Count(T->lchild);
    n2 = Count(T->rchild);
    if(T->lchild && T->rchild){
        return n1 + n2;
    }else if(T->lchild || T->rchild){
        return n1 + n2 + 1;
    }else{
        return 0;
    }
}
```

### 4.11. æ±‚ä¸€é¢—äºŒå‰æ ‘çš„æ·±åº¦

```c
int Depth(BiTree T){
    int ldep,rdep;
    if(T == NULL) return 0;
    ldep = Depth(T->lchild);
    rdep = Depth(T->rchild);
    if(ldep > rdep){
        return ldep + 1;
    }else{
        return rdep + 1;
    }
}
```

### 4.12. è®¾æ ‘ B æ˜¯ä¸€æ£µé‡‡ç”¨äºŒå‰é“¾è¡¨å½¢å¼å­˜å‚¨çš„äºŒå‰æ ‘ç¼–å†™ä¸€ä¸ªæŠŠæ ‘ B ä¸­æ‰€æœ‰ç»“ç‚¹çš„å·¦ã€å³å­æ ‘è¿›è¡Œäº¤æ¢çš„å‡½æ•°ã€‚

```c
void ChangeChild(BiTree &T){
    BNode *p;
    if(T == NULL) return;
    p = T->lhild;
    T->lchild = T->rchild;
    T->rchild = p;
    ChangeChild(T->lchild);
    ChangeChild(T->rchild);
}
```

### 4.13. å‡è®¾äºŒå‰æ ‘é‡‡ç”¨äºŒå‰é“¾è¡¨å­˜å‚¨ç»“æ„ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚äºŒå‰æ ‘ T ä¸­å€¼ä¸º x çš„ç»“ç‚¹çš„å±‚æ¬¡å·ã€‚

```c
void Search_x_level(BiTree T,int x,int level){ // æ­¤å¤„çš„level = 1
    if(T != NULL){
        if(T->data == x){
            printf("%d",level);
        }
        Search_x_level(T->lchild,x,level+1);
        Search_x_level(T->rchild,x,level+1);
    }
}
```

### 4.14. è¯·å†™å‡ºäºŒå‰æ ‘å±‚æ¬¡éå†ç®—æ³•

```c
// éé€’å½’
void LevelOrder(BiTree T){
    BiTNode p = T;
    Queue Q; // å®šä¹‰ä¸€ä¸ªè¾…åŠ©é˜Ÿåˆ—
    InitQueue(Q);
    EnQueue(p);
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        printf("%d",p->data);
        if(p->lchild){
            EnQueue(Q,p->lchild); // pçš„å·¦å­©å­å…¥é˜Ÿ,ä¸‹ä¸€æ¬¡å¾ªç¯å‡ºé˜Ÿæ—¶p = p->*child
        }
        if(p->rchild){
            EnQueue(Q,p->rchild);
        }
    }
}
```

### 4.15. è¯•å†™å‡ºäºŒå‰æ ‘çš„è‡ªä¸‹è€Œä¸Šã€ä»å³åˆ°å·¦çš„å±‚æ¬¡éå†ç®—æ³•

```c
void ReverseLevelOrder(BiTree T){
    Queueã€€Q;
    Stack S;
    InitQueue(Q);
    InitStack(S);
    BiTNode *p = T;
    EnQueue(Q, p);
    while(!IsEmpty(Q)){
        DeQueue(Q,p);
        Push(S, p); // ä¸æ‰“å°,è€Œæ˜¯å‹æ ˆ
        if(p->lchild){
            EnQueue(Q,p->lchild); // pçš„å·¦å­©å­å…¥é˜Ÿ,ä¸‹ä¸€æ¬¡å¾ªç¯å‡ºé˜Ÿæ—¶p = p->*child
        }
        if(p->rchild){
            EnQueue(Q,p->rchild);
        }
    }
    while(!IsEmpty2(S)){
        Pop(S,p);
        printf("%d",p->data);
    }
}
```

### 4.16. äºŒå‰æ ‘æŒ‰äºŒå‰é“¾è¡¨å½¢å¼å­˜å‚¨ï¼Œå†™ä¸€ä¸ªåˆ¤åˆ«ç»™å®šäºŒå‰æ ‘æ˜¯å¦æ˜¯å®Œå…¨äºŒå‰æ ‘çš„ç®—æ³•

```c
int IsComplete(BiTree T){
    if(T == NULL) return 1;
    Queue Q;
    InitQueue(Q);
    BiTNode *p = T;
    EnQueue(Q, p);
    while(!IsEmpty(Q)){
        DeQueue(Q, p);
        if(p != NULL){
            EnQueue(Q, p->lchild);
            EnQueue(Q, p->rchild);
        }else{
            while(!IsEmpty(Q)){ // pä¸ºç©º,Qä¸ä¸ºç©ºçš„æƒ…å†µ |p(æ­¤æ—¶pä¸ºç©º)|NULL|NULL|NULL|
                DeQueue(Q,p);
                if(p != NULL){
                    return 0;
                }
            }
        }
    }
    return 1;
}
```

### 4.17. å·²çŸ¥äºŒå‰æ ‘é‡‡ç”¨äºŒå‰é“¾è¡¨å½¢å¼å­˜å‚¨ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•å®Œæˆï¼šå¯¹äºæ ‘ä¸­æ¯ä¸ªå…ƒç´ å€¼ä¸º x çš„ç»“ç‚¹ï¼Œåˆ å»ä»¥å®ƒä¸ºæ ¹çš„å­æ ‘ï¼Œå¹¶é‡Šæ”¾ç›¸åº”çš„ç©ºé—´ã€‚

```c
void DeleteTree(BiTree &T){
    if(T != NULL){
        DeleteTree(T->lchild);
        DeleteTree(T->rchild);
        free(T);
    }
}

void SearchX(BiTree &T, int x){
    if(T == NULL) return;
    Queue Q;
    InitQueue(Q);
    BiTNode *p;
    while(!IsQueue(Q)){
        DeQueue(Q, p);
        if(p->lchild){
            if(p->lchild->data == x){
                DeleteTree(T->lchild);
                T->lchild = NULL;
            }else{
                EnQueue(Q, p->lchild);
            }
        }
        if(p->rchild){
            if(p->rchild->data == x){
                DeleteTree(T->rchild);
                T->rchild = NULL;
            }else{
                EnQueue(Q, p->rchild);
            }
        }
    }
}
```

### 4.18. éé€’å½’ç®—æ³•æ±‚äºŒå‰æ ‘é«˜åº¦.

````c
``` int Depth(BiTree T){
    if(T == NULL) return 0;
    int h = 0, last = 0;
    BiTNode *Q [MaxSize];
    int front = -1, rear = -1;
    BiTNode *p = T;
    Q [++rear] = p;
    while(! IsEmpty(Q)){
        p = Q [++front];
        if(p-> lchild){
            Q [++rear] = p-> lchild;
        }
        if(p-> rchild){
            Q [++rear] = p-> rchild;
        }
        if(front == last){
            last = rear;
            h++;
        }
    }
    return h;
}
````

### 4.19. å‡è®¾äºŒå‰æ ‘é‡‡ç”¨äºŒå‰é“¾è¡¨å­˜å‚¨ç»“æ„ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚ç»™å®šçš„äºŒå‰æ ‘å®½åº¦ï¼ˆå³å…·æœ‰ç»“ç‚¹æ•°æœ€å¤šçš„é‚£ä¸€å±‚çš„ç»“ç‚¹ä¸ªæ•°)ã€‚<span style="font-size:0.6em; text-decoration:line-through;">(æœ‰è¾£ä¹ˆä¸€å¨å˜é‡,å•Šå•Šå•Š)</span>

```c
int Width(BiTree T){
    if(T == NULL) return;
    BTNode *Q [MaxSize]; // ç”¨äºå±‚åºéå†
    int front = 0, rear = 0;
    int level [MaxSize]; // ç”¨æ¥å­˜å‚¨ç»“ç‚¹å±äºå“ªä¸€ä¸ªå±‚çº§
    BiTree *p;
    int k = 1; // ç”¨äºè®°å½•å±‚çº§
    Q [rear] = p;
    level [rear] = k;
    rear++;
    while(front < rear){
        p = Q [front];
        k = level [front];
        front++;
        if(p-> lchild){
            Q [rear] = p-> lchild;
            level [rear] = k+1; // å±‚çº§+1
            rear++;
        }
        if(p-> lchild){
            Q [rear] = p-> rchild;
            level [rear] = k+1;
            rear++;
        }
    }
    // while å¾ªç¯ç»“æŸ, level é‡Œå­˜æœ‰è¿™æ ·çš„æ•°æ® |1|2|2|3| å¯¹åº” |ç¬¬ä¸€å±‚|ç¬¬äºŒå±‚|ç¬¬ä¸‰å±‚
    int max = 0, n, i = 0; // i æ˜¯ç”¨äºéå† level çš„
    k = 1; // é‡ç½® k
    while(i < rear){
        n = 0;
        while(i < rear && level [i] == k){
            n++; // n ä¼šåœ¨æ¯è½®é‡ç½®, è®°å½•å®½
            i++; // i æ˜¯ä¸€ç›´åœ¨+çš„
        } // ä¸€å±‚ç»“æŸ
        k++; // å±‚çº§+1
        if(n > max){
            max = n;
        }
    }
    return max;
}
```

### 4.20. è¯·å†™å‡ºä¸­åºéé€’å½’éå†äºŒå‰æ ‘çš„ç®—æ³•

```c
void MidOrder(BiTree T){
    Stack S;
    InitStack(S);
    BiTNode *p = T;
    while(p || ! IsEmpty(S)){
        if(p != NULL){
            //print("%d", p); // å…ˆåº
            Push(S, p);
            p = p-> lchild;
        }else{
            Pop(S, p);
            print("%d", p);
            p = p-> rchild;
        }
    }
}
```

### 4.21. è¯·å†™å‡ºååºéé€’å½’éå†äºŒå‰æ ‘çš„ç®—æ³•

> èµ·æ‰‹:`int p, r; Stack S`

```c
// éœ€è¦å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆ r, æŒ‡å‘ç»“ç‚¹çš„å³ç»“ç‚¹
void PostOrder(BiTree T){
    Stack S;
    InitStack(S);
    BiTNode *p = T;
    BiTNode *r = NULL;
    while(p || ! Empty(S)){ // [! code highlight]
        if(p != NULL){ // [! code highlight]
            Push(S, p); // [! code highlight]
            p = p-> lchild; // [! code highlight]
        }else{ // [! code highlight]
            if(p-> rchild && p-> rchild != r){ // [! code highlight]
                GetTop(S, p);
                p = p-> rchild;
            }else{
                Pop(S, p); // [! code highlight]
                printf("%d", p);
                r = p; // [! code highlight]
                p = NULL; // æ˜“æ¼ // [! code highlight]
            }
        }
    }
}
```

### 4.22. åœ¨äºŒå‰æ ‘ä¸­æŸ¥æ‰¾å€¼ä¸ºxçš„ç»“ç‚¹ï¼Œè¯•ç¼–å†™ç®—æ³•æ‰“å°å€¼ä¸ºxçš„ç»“ç‚¹çš„æ‰€æœ‰ç¥–å…ˆï¼Œå‡è®¾å€¼ä¸ºxçš„ç»“ç‚¹ä¸å¤šäºä¸€ä¸ªã€‚

```c
void Func(BiTree T, int x){
    Stack S;
    InitStack(S);
    BiTNode *p = T,* r = NULL;
    while(p || ! IsEmpty(S)){
        if(p != NULL){
            Push(S, p);
            p = p-> lchild; // [! code highlight]
        }else{
            GetTop(S, p);
            if(p-> rchild && p-> rchild != r){
                p = p-> rchild; // [! code highlight]
            }else{
                Pop(S, p);
                if(p-> data == x){
                    while(! IsEmpty(S)){
                        Pop(S, p);
                        printf("%d", p-> data)
                    }
                }
                r = p;
                p = NULL;
            }
        }
    }
}
```

### 4.23. på’Œqåˆ†åˆ«ä¸ºæŒ‡å‘ä¸€æ£µäºŒå‰æ ‘ä¸­ä»»æ„ä¸¤ä¸ªç»“ç‚¹çš„æŒ‡é’ˆï¼Œè¯•ç¼–å†™ç®—æ³•æ‰¾åˆ°på’Œqæœ€è¿‘å…¬å…±ç»“ç‚¹å¹¶è¿”å›

> å¯¹ååºéå†ç®—æ³•çš„æ”¹å†™

```c
BiTree *FindAncestor(BiTree T, BiTNode p, BiTNode q){
    BiTNode *bt = T,* r = NULL;
    BiTNode * S [MaxSize], S1 [MaxSize], S2 [MaxSize];
    int top = -1, top1 = -1, top2 = -1;
    int temp;
    while(p || top != -1){
        if(bt != NULL){
            S [++top] = bt; // [! code highlight]
            bt = bt-> lchild;
        }else{
            bt = S [top];
            if(bt-> rchild && bt-> rchild != r){
                bt = bt-> rchild;
            }else{
                bt = S [top--]; // [! code highlight]
                if(bt == p){
                    for(temp = 0; temp < top; temp++){
                        S1 [temp] = S [temp];
                        top1++;
                    }
                }
                if(bt == q){
                    for(temp = 0; temp < top; temp++){
                        S2 [temp] = S [temp];
                        top2++;
                    }
                }
                r = bt;
                bt = NULL;
            }
        }
    }
    for(int i = top1; i >= 0; i--){
        for(int j = top2; j >= 0; j--){
            if(S1 [i] == S2 [j]){
                return S1 [i];
            }
        }
    }
    return NULL;
}
```

### 4.24. å‡è®¾ä¸€æ£µäºŒå‰æ ‘ä»¥äºŒå‰é“¾è¡¨å­˜å‚¨æ–¹å¼å­˜å‚¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œè¾“å‡ºæ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­ç»“ç‚¹çš„è·¯å¾„ã€‚

```c
void AllPath(BiTree T){
    BiTNode *p = T, * r = NULL;
    BiTNode *S [MaxSize];
    int top = -1;
    while(p != NULL || top == -1){
        if(p != NULL){
            S [++top] = p;
            p = p-> lchild;
        }else{
            p = S [top--];
            if(p-> lchild == NULL && p-> rchild == NULL){
                for(int i = top, i >= 0, i--){
                    printf("%d", S [i]-> data);
                }
                print("%d", p-> data);
            }
        }
        r = p;
        p = NULL;
    }
}
```

### 4.25. è®¾è®¡ä¸€ä¸ªç®—æ³•å°†äºŒå‰æ ‘çš„å¶å­ç»“ç‚¹æŒ‰ä»å·¦åˆ°å³çš„é¡ºåºè¿æˆä¸€ä¸ªå•é“¾è¡¨ï¼Œè¡¨å¤´æŒ‡é’ˆä¸ºheadã€‚äºŒå‰æ ‘æŒ‰äºŒå‰é“¾è¡¨æ–¹å¼å­˜å‚¨ï¼Œé“¾æ¥æ—¶ç”¨å¶å­ç»“ç‚¹çš„å³æŒ‡é’ˆåŸŸæ¥å­˜æ”¾å•é“¾è¡¨æŒ‡é’ˆã€‚

```c
BiTNode *head = NULL, * pre = NULL;
void Link(BiTree &T){
    if(T!= NULL){
        Link(T-> lchild);
        if(T-> lchild == NULL && T-> rchild == NULL){
            if(pre == NULL){
                head = T;
                pre = T;
            }else{
                pre-> rchild = T;
                pre = T
            }
        }
    }
}
```

### 4.26. è¡¨è¾¾å¼(a-(b+c)\*(d/e)å­˜å‚¨åœ¨å¦‚ä¸‹å›¾æ‰€ç¤ºçš„ä¸€æ£µä»¥äºŒå‰é“¾è¡¨ä¸ºå­˜å‚¨ç»“æ„çš„äºŒå‰æ ‘ä¸­ï¼ˆäºŒå‰æ ‘ç»“ç‚¹çš„ dataåŸŸä¸ºå­—ç¬¦å‹)ï¼Œç¼–å†™ç¨‹åºæ±‚å‡ºè¯¥è¡¨è¾¾å¼çš„å€¼ï¼ˆè¡¨è¾¾å¼ä¸­çš„æ“ä½œæ•°éƒ½æ˜¯ä¸€ä½çš„æ•´æ•°ï¼‰ã€‚è¯´æ˜ï¼šå‡½æ•° int op(int A,int B,char C)è¿”å›çš„æ˜¯ä»¥Cä¸ºè¿ç®—ç¬¦ï¼Œä»¥Aã€Bä¸ºæ“ä½œæ•°çš„ç®—å¼çš„æ•°å€¼ï¼Œä¾‹å¦‚ï¼Œè‹¥Cä¸º"+"ï¼Œåˆ™è¿”å›A+Bçš„å€¼ã€‚

```c
int Compute(BiTree T){
    if(T == NULL){
        return 0;
    }
    int A, B;
    if(T-> lchild == NULL && T-> rchild == NULL){
        A = Compute(T-> lchild);
        B = Compute(T-> rchild);
    }else{
        return T-> data - "0";
    }
}
```

### 4.27. è¯•è®¾è®¡åˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ç›¸ä¼¼çš„ä»£ç 

```c
int Similar(BiTree T1, BiTree T2){
    int left, right;
    if(T1 == NULL && T2 == NULL){
        return 1;
    }else if(T1 == NULL ||ã€€ï¼´2 == NULL){
        return 0;
    }else{
        left = Similar(T1-> lchild, T2-> lchild);
        right = Similar(T1-> rchild, T2-> rchild);
        return left && right;
    }
}
```

### 4.28. åœ¨äºŒå‰æ ‘çš„äºŒå‰é“¾è¡¨å­˜å‚¨ç»“æ„ä¸­ï¼Œå¢åŠ ä¸€ä¸ªæŒ‡å‘åŒäº²ç»“ç‚¹çš„parentæŒ‡é’ˆï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œç»™è¿™ä¸ªæŒ‡é’ˆèµ‹å€¼ï¼Œå¹¶è¾“å‡ºæ‰€æœ‰ç»“ç‚¹åˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„ã€‚

```c
typedef struct BiTNode{
    char data;
    struct BiTNode *left, * right, *parent;
} BiTNode, *BiTree;

void Func(BiTree &T, BiTNode *q){
    if(T != NULL){
        T-> parent = q;
        q = T;
        Func(T-> lchild);
        Func(T-> rchild);
    }
}

void PathPrint(BiTNode *p){
    while(p != NULL){
        printf("%c", p-> data);
        p = p-> parent;
    }
}

void AllPrint(BiTree T){
    if(T != NULL){
        pathPrint(T);
        AllPrint(T-> lchild);
        AllPrint(T-> rchild);
    }
}
```

### 4.29. æœ‰ä¸€æ£µäºŒå‰æ ‘ä»¥é¡ºåºå­˜å‚¨çš„æ–¹å¼å­˜åœ¨ä¸€ç»´æ•°ç»„Aä¸­ï¼Œæ ‘ä¸­ç»“ç‚¹å­˜å‚¨æ•°æ®ä¸ºå­—ç¬¦å‹ï¼Œç©ºæŒ‡é’ˆåŸŸåœ¨æ•°ç»„ä¸­ä»¥å­—ç¬¦'#'è¡¨ç¤ºï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•å°†å…¶æ”¹ä¸ºäºŒå‰é“¾è¡¨çš„å­˜å‚¨æ–¹å¼ã€‚ï¼ˆå‡è®¾æ•°ç»„Aä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨å…ƒç´ ï¼Œå­˜å‚¨å…ƒç´ ä¸ªæ•°ä¸ºn)

```c
BiTree Create(char A [], int i, int n){
    if(i > n || A [i] == '#'){
        return NULL;
    }else{
        BiTNode *p = (BiTNode *)malloc(sizeof(BiTree));
        p-> data = A [i];
        p-> lchild = Create(A, 2*i, n);
        p-> rchild = Create(A, 2*i+1, n);
        return p;
    }
}
```

### 4.30. è®¾ä¸€æ£µäºŒå‰æ ‘ä¸­å„ç»“ç‚¹çš„å€¼äº’ä¸ç›¸åŒï¼Œå…¶å…ˆåºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—åˆ†åˆ«å­˜äºä¸¤ä¸ªä¸€ç»´æ•°ç»„ A[1...n]å’ŒB[1...n]ä¸­ï¼Œè¯•ç¼–å†™ç®—æ³•å»ºç«‹è¯¥äºŒå‰æ ‘çš„äºŒå‰é“¾è¡¨ã€‚<span style="font-size:0.7em; color:#FFFF00;">(è¿™tmæ˜¯ä»€ä¹ˆä¸œè¥¿,ç†è§£ä¸èƒ½)</span>

```c
BiTree Create(char A [], int L1, int h1, char B [], int L2, int h2){
    BiTNode *p = (BiTNode *)malloc(sizeof(BTNode));
    p-> data = A [i];
    int i;
    for(i = L2; B [i] != p-> data, i++);
    int llen = i-L2;
    int rlen = h2-i;
    if(llen) p-> lchild = Create(A, L1+1, L1+llen, B, L2+len-1, h1);
    else p-> lchild = NULL;
    if(rchild) p-> rchild = Create(A, h1-rlen+1, h1, B, h2-rlen+1, h2);
    else p-> rchild = NULL;
    return p;
}
```

### 4.31. è®¾æœ‰ä¸€æ£µæ»¡äºŒå‰æ ‘ï¼ˆæ‰€æœ‰ç»“ç‚¹å€¼å‡ä¸åŒï¼‰ï¼Œå·²çŸ¥å…¶å…ˆåºåºåˆ—ä¸ºpre,è®¾è®¡ä¸€ä¸ªç®—æ³•æ±‚å…¶ååºåºåˆ—post

```c
void PreToPost(char pre [], int l1, int h1, char post [], int l2, int h2){
    int half;
    if(h1 >= l1){
        post [h2] = pre [l1];
        half = (h1 - h2)/2;
        PreToPost(pre, l1+1, l1+half, post, l2, l2+half-1);
        PreToPost(pre, l1+1+half, h1, post, l2+half, h2-1);
    }
}
```

## 5. æŸ¥æ‰¾å’Œæ’åº

### 5.1. æ•°ç»„A[]ä¸­æœ‰ä¸ªæ•´æ•°ï¼Œæ²¡æœ‰æ¬¡åºï¼Œæ•°ç»„ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨ï¼Œè¯·å†™å‡ºæŸ¥æ‰¾ä»»ä¸€å…ƒç´ kçš„ç®—æ³•ï¼Œè‹¥æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼›è‹¥æŸ¥æ‰¾ä¸æˆåŠŸï¼Œåˆ™è¿”å›0ã€‚

```c
ç•¥ ä¸€ä¸ª for å¾ªç¯
```

### 5.2. å·²çŸ¥ä¸€ä¸ªé¡ºåºè¡¨Lï¼Œå…¶ä¸­çš„å…ƒç´ é€’å¢æœ‰åºæ’åˆ—ï¼Œè¯·åˆ†åˆ«å†™å‡ºæŠ˜åŠæŸ¥æ‰¾çš„é€’å½’ç®—æ³•å’Œéé€’å½’ç®—æ³•æŸ¥æ‰¾Lä¸­å€¼ä¸ºkeyçš„å…ƒç´ ä½ç½®ã€‚

::: code-group

```c [éé€’å½’ç®—æ³•]
int BinarySearch(SqList L, int key){
    int low = 0, high = L.length - 1, mid;
    while(low <= high){
        mid = (low+high)/2;
        if(L.daata [mid] == key){
            return mid;
        }else if(L.data [mid] > key){
            high = mid -1;
        }else{
            low = mid + 1;
        }
    }
    return -1;
}
```

```c [é€’å½’ç®—æ³•]
int BinarySearch(SqList L, int key, int low, int high){
    if(low > high) return -1;
    int mid = (low+high)/2;
    if(L.data [mid] < key){
        return BinarySearch(L, key, mid+1, high);
    }else if(L.data [mid] > key){
        return BinarySearch(L, key, low, mid-1);
    }else{
        return mid;
    }
}
```

:::

### 5.3. çº¿æ€§è¡¨ä¸­å„ç»“ç‚¹çš„æ£€ç´¢æ¦‚ç‡ä¸ç­‰æ—¶ï¼Œå¯ç”¨å¦‚ä¸‹ç­–ç•¥æé«˜é¡ºåºæ£€ç´¢çš„æ•ˆç‡ï¼šè‹¥æ‰¾åˆ°æŒ‡å®šçš„ç»“ç‚¹ï¼Œåˆ™å°†è¯¥ç»“ç‚¹å’Œå…¶å‰é©±ç»“ç‚¹ï¼ˆè‹¥å­˜åœ¨ï¼‰äº¤æ¢ï¼Œä½¿å¾—ç»å¸¸è¢«æ£€ç´¢çš„ç»“ç‚¹å°½é‡ä½äºè¡¨çš„å‰ç«¯ã€‚è¯•è®¾è®¡åœ¨é¡ºåºç»“æ„å’Œé“¾å¼ç»“æ„çš„çº¿æ€§è¡¨ä¸Šå®ç°ä¸Šè¿°ç­–ç•¥çš„é¡ºåºæ£€ç´¢ç®—æ³•ã€‚

::: code-group

```c [é¡ºåºç»“æ„]
void SqListSearch(SqList &L, int k){
    if(L.data [0] == k){
        return;
    }
    for(int i = 1; L.length-1; i++){
        if(L.data [i] == k){
            int temp;
            temp = L.data [i];
            L.data [i] = L.data [i-1];
            L.data [i-1] = temp;
        }
    }
}
```

```c [é“¾å¼ç»“æ„]
void LinkListSearch(LinkList &L, int k){
    if(p-> next-> next-> data == k){
        return;
    }
    LNode *p = L;
    while(p-> next-> next){
        if(p-> next-> next-> data = k){
            LNode *q = p-> next, * r = p-> next-> next;
            q-> next = r-> next;
            p-> next = r;
            r-> next = q;
            return;
        }
        p = p-> next;
    }
}
```

:::

### 5.4. è¯·åˆ†åˆ«å†™å‡ºåœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾æ•°æ®åŸŸå€¼ä¸ºkç»“ç‚¹ä½ç½®çš„é€’å½’ç®—æ³•å’Œéé€’å½’ç®—æ³•ã€‚

::: code-group

```c [éé€’å½’éå†]
BiTNode *Search(BiTree T, int k){
    while(T!= NULL){
        if(T-> data > k){
            T = T-> lchild;
        }else if(T-> data < k){
            T = T-> rchild;
        }else{
            return T;
        }
    }
    return NULL;
}
```

```c [é€’å½’éå†]
BiTNode *Search(BiTree T, int k){
    if(T == NULL){
        return NULL;
    }else {
        if(T-> data == k){
            return T;
        }else if(T-> data > k){
            return Search(T-> lchild, k);
        }else {
            return Search(T-> rchild, k);
        }
    }
}
```

:::

### 5.5. è¯·å†™å‡ºåœ¨ä¸€æ£µäºŒå‰æ’åºæ ‘Tä¸­æ’å…¥å€¼ä¸ºkç»“ç‚¹çš„ç®—æ³•ï¼Œæ’å…¥æˆåŠŸåˆ™è¿”å›1ï¼Œæ’å…¥å¤±è´¥åˆ™è¿”å›0ï¼Œç„¶åå†™å‡ºæ ¹æ®æ•°ç»„Aä¸­å­˜å‚¨å…ƒç´ å€¼é¡ºåºæ„é€ ä¸€æ£µäºŒå‰æ’åºæ ‘çš„ç®—æ³•ï¼Œå‡è®¾æ•°ç»„Açš„é•¿åº¦ä¸ºã€‚

```c
// æ’å…¥
int BST_Insert(BiTree &T, int k){
    if(T == NULL){
        T = (BiTNode *)malloc(sizeof(BiTNode));
        T-> data = k;
        T-> lchild = NULL;
        T-> rchild = NULL;
        return 1;
    }else if(T-> data > k){
        return BST_Insert(T-> lchild, k);
    }else if(T-> data < k){
        return BST_Insert(T-> rchild, k);
    }else {
        return 0;
    }
}
// æ„é€ 
void Create_BST(BiTree &T int A [], int n){
    T = NULL;
    int i = 0;
    while(i < n){
        BST_Insert(T, A [i]);
        i++;
    }
}
```

### 5.6. è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å‡ºç»™å®šäºŒå‰æ’åºæ ‘ä¸­æœ€å°å’Œæœ€å¤§çš„å…³é”®å­—

```c
ç•¥ ä¸€ä¸ª while å¾ªç¯
```

### 5.7. è¯•ç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œæ±‚å‡ºæŒ‡å®šç»“ç‚¹åœ¨ç»™å®šäºŒå‰æ’åºæ ‘ä¸­çš„å±‚æ¬¡ã€‚

```c
int level(BiTree T, BiTNode *p){
    int n = 1;
    while(T != p){
        if(T-> data < p-> data){
            T = T-> rchild;
        }else{
            T = T-> lchild;
        }
        n++;
    }
    return n;
}
```

### 5.8. è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œä»å¤§åˆ°å°è¾“å‡ºäºŒå‰æ’åºæ ‘ä¸­æ‰€æœ‰å€¼ä¸å°äºkçš„å…³é”®å­—

```c
void Func(BiTree T, int k){
    if(T != NULL){
        Func(T-> rchild, k);
        if(T-> data >= k){
            printf("%d", T-> data);
        }
        Func(T-> lchild, k);
    }
}
```

### 5.9. è¯•ç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­ç»™å®šçš„äºŒå‰æ ‘æ˜¯å¦æ˜¯äºŒå‰æ’åºæ ‘ã€‚

```c
// æ”¹å†™ä¸­åºéå†
int JudgeBST(BiTree T, int &pre){
    int b1, b2;
    if(T == NULL){
        return 1;
    }else{
        b1 = JudgeBST(T-> lchild, pre);
        if(b1 == NULL || T-> data <= pre){
            return 0;
        }
        pre = T-> data;
        b2 = JudgeBST(T-> rchild, pre);
        return b2;
    }
}
```

### 5.10. è¯•ç¼–å†™ä¸€ä¸ªåˆ¤æ–­äºŒå‰æ’åºæ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘çš„ç®—æ³•ã€‚

```c
int Func(BiTree T){
    if(T == NULL){
        return 0;
    }
    int left = Func(T-> lchild);
    int right = Func(T-> rchild);
    if(left == -1 || right == -1 || abs(left-right) > 1){
        return -1;
    }else{
        return max(left, right) + 1; // è¿”å›é«˜åº¦
    }
}
```

### 5.11. åœ¨å¹³è¡¡äºŒå‰æ ‘çš„æ¯ä¸ªç»“ç‚¹ä¸­å¢è®¾ä¸€ä¸ªåŸŸlsize,å­˜å‚¨ä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹çš„å·¦å­æ ‘ä¸­çš„ç»“ç‚¹ä¸ªæ•°åŠ ä¸€ã€‚ç¼–å†™ä¸€ä¸ªç®—æ³•ï¼Œç¡®å®šæ ‘ä¸­ç¬¬kå°ç»“ç‚¹çš„ä½ç½®ã€‚

```c
BTNode *Search_k(BiTree T, int k){
    if(T == NULL || k < 1){
        return NULL;
    }else if(T-> lsize == k){
        return T;
    }else if(T-> lsize > k){
        return Search_k(T-> child, k);
    }else{
        return Search_k(T-> rchild, k-T-> lchild);
    }
}
```

### 5.12. ç¼–å†™ä¸€ä¸ªé€’å½’ç®—æ³•ï¼Œåœ¨ä¸€æ£µæœ‰nä¸ªç»“ç‚¹çš„ã€éšæœºå»ºç«‹èµ·æ¥çš„äºŒå‰æ’åºæ ‘ä¸ŠæŸ¥æ‰¾ç¬¬kå°çš„å…ƒç´ ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥ç»“ç‚¹çš„æŒ‡é’ˆã€‚è¦æ±‚ç®—æ³•çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸ºO(log_n)ã€‚äºŒå‰æ’åºæ ‘çš„æ¯ä¸ªç»“ç‚¹ä¸­é™¤ data,lchild,.rchildç­‰æ•°æ®æˆå‘˜å¤–ï¼Œå¢åŠ ä¸€ä¸ªcountæˆå‘˜ï¼Œä¿å­˜ä»¥è¯¥ç»“ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚

```c
BiTNode *Search_k(BiTree T, int k){
    if(k < 1 || kã€€> T-> count){
        return NULL;
    }
    if(T-> lchild == NULL){
        if(k == 1){
            return T;
        }else{
            return Search_k(T-> rchild, k-1);
        }
    }else{
        if(T-> lchild-> count == k-1){
            return T;
        }else if(T-> lchild-> count > k-1){
            return Search_k(T-> lchild, k);
        }else{
            return Search_k(T-> rchild, k-1-T-> lchild-> count);
        }
    }
}
```

### 5.13. è¯·åˆ†åˆ«å†™å‡ºé¡ºåºå­˜å‚¨å’Œé“¾å¼å­˜å‚¨çš„ç›´æ¥æ’å…¥æ’åºç®—æ³•

::: code-group

```c [é¡ºåºå­˜å‚¨]
void InsertSort(int A [], int n){
    int i, j;
    for(i = 2; i <= n; i++){
        if(A [i] < A [i-1]){
            A [0] = A [i];
            for(j = i-1; A [j] > A [0], j--){
                A [j+1] = A [j];
            }
            A [j+1] = A [0];
        }
    }
}
```

```c [é“¾å¼å­˜å‚¨]
void InsertSort(SqList &L){
    if(L-> next == NULL){
        return;
    }
    LNode *pre,* q, *p,* r;
    p = L-> next-> next;
    L-> next-> next = NULL;
    while(p != NULL){
        pre = L;
        q = pre-> next;
        while(q != NULL && q-> data <= p-> data){
            pre = q;
            q = pre-> next;
        }
        r = p-> next;
        p-> next = q;
        pre-> next = p;
        p = r;
    }
}
```

:::

### 5.14. æœ‰ä¸€ä¸ªæ•°ç»„Aå­˜å‚¨ç€m+nä¸ªæ•´å‹å…ƒç´ ï¼Œå…ƒç´ ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨ï¼Œå…¶å‰mä¸ªå…ƒç´ é€’å¢æœ‰åºï¼Œånä¸ªå…ƒç´ é€’å¢æœ‰åºï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ä½¿è¿™ä¸ªæ•°ç»„æ•´ä½“æœ‰åºã€‚

```c
void InsertSort(int A [], int m, int n){
    int i, j;
    for(i = m+1; i < m+n; i++){
        if(A [i] < A [i-1]){
            A [0] = A [i];
            for(j = i-1; A [j] < A [0]; j--){
                A [j+1] = A [j];
            }
            A [j+1] = A [0];
        }
    }
}
```

### 5.15. è¯·å†™å‡ºæŠ˜åŠæ’å…¥æ’åºç®—æ³•ã€‚

```c
void InsertSort(int A [], int n){
    int i, j, low, high, mid;
    for(i = 2; i <= n; i++){
        A [0] = A [i];
        low = 1;
        high = i - 1;
        while(low <= high){
            mid = (low+high)/2;
            if(A [mid] > A [0]){
                high = mid - 1;
            }else {
                low = high + 1;
            }
        }
        for(j = i-1; j >= low; j--){
            A [j+1] = A [j];
        }
        A [j+1] = A [0];
    }
}
```

### 5.16. è¯·å†™å‡ºå†’æ³¡æ’åºçš„ç®—æ³•

```c
void BubbleSort(int A [], int n){
    int i, j, temp;
    int flag;
    for(i = 0; i < n-1; i++){
        flag = 0;
        for(j = n-1; j > i; j--){
            if(A [j-1] > A [j]){
                temp = A [j];
                A [j] = A [j-1];
                A [j-1] = temp;
                flag = 1;
            }
        }
        if(flag == 0){
            return;
        }
    }
}
```

### 5.17. ç¼–å†™åŒå‘å†’æ³¡æ’åºç®—æ³•ï¼Œåœ¨æ­£åä¸¤ä¸ªæ–¹å‘äº¤æ›¿è¿›è¡Œæ‰«æï¼Œå³ç¬¬ä¸€è¶ŸæŠŠå…³é”®å­—æœ€å¤§çš„å…ƒç´ æ”¾åœ¨åºåˆ—çš„æœ€åé¢ï¼Œç¬¬äºŒè¶ŸæŠŠå…³é”®å­—æœ€å°çš„å…ƒç´ æ”¾åœ¨åºåˆ—çš„æœ€å‰é¢ï¼Œå¦‚æ­¤åå¤è¿›è¡Œã€‚

```c
void Bubble(int A [], int n){
    int low = 0, high = n-1;
    int temp, flag = 1;
    while(low < high && flag == 1){
        flag = 0;
        for(i = low; i < high; i++){
            if(A [i] > A [i+1]){
                temp = A [i];
                A [i] = A [i+1];
                A [i+1] = A [i];
                flag = 1;
            }
        }
        high--;
        for(i = high; i > low; i--){
            if(A [i] < A [i-1]){
                temp = A [i];
                A [i] = A [i-1];
                A [i-1] = A [i];
                flag = 1;
            }
        }
        low--;
    }
}
```

### 5.18. è¯·å†™å‡ºå¿«é€Ÿæ’åºç®—æ³•

```c
// å•æ¬¡åˆ’åˆ†
int Partition(int A [], int low, int high){
    int pivot = A [low];
    while(low < high){
        while(low < high && A[high] > = pivot){
            high--;
        }
        A [low] = A [high];
        while(low < high && A [low] <= pivot){
            low++;
        }
        A [high] = A [low];
    }
    A [low] = pivot;
    return low;
}
// å¿«é€Ÿæ’åº
void QuickSort(int A [], int low, int high){
    if(low < high){
        int pivotpos = Partition(A, low, high);
        QuickSort(A, low, pivotpos-1);
        QuickSort(A, pivotpos+1, high);
    }
}
```

### 5.19. æœ‰ä¸€ä¸ªæ•´å‹æ•°ç»„Aå­˜å‚¨äº†nä¸ªå…ƒç´ ï¼Œå…¶å…ƒç´ åºåˆ—æ˜¯æ— åºçš„ï¼Œå…ƒç´ ä»ä¸‹æ ‡ä¸º1å¼€å§‹å­˜å‚¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•è®©æ•°ç»„Aä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ æ”¾åœ¨æ•°ç»„Aæ•´ä½“æ’åºåçš„æ­£ç¡®ä½ç½®ä¸Šï¼Œç»“æœè¿”å›å…¶æ•°ç»„ä¸‹æ ‡ï¼Œè¦æ±‚å…³é”®å­—çš„æ¯”è¾ƒæ¬¡æ•°ä¸è¶…è¿‡nã€‚

```c
int Partition(int A [], int n){
    int low = 0, high = n;
    int pivot = A [high];
    while(low < high){
        while(low < high && A[high] > = pivot){
            high--;
        }
        A [low] = A [high];
        while(low < high && A [low] <= pivot){
            low++;
        }
        A [high] = A [low];
    }
    A [low] = pivot;
    return low;
}
```

### 5.20. è¯·è®¾è®¡ä¸€ä¸ªå°½å¯èƒ½é«˜æ•ˆçš„ç®—æ³•ï¼Œä½¿ä¹‹èƒ½å¤Ÿåœ¨æ•°ç»„A[1..]ä¸­æ‰¾å‡ºç¬¬kå°çš„å…ƒç´ ï¼ˆå³ä»å°åˆ°å¤§æ’åºåå¤„äºç¬¬kä¸ªä½ç½®çš„å…ƒç´ )ã€‚

```c
int Search_k(int A [], int low, int high, int k){
    int pivot = A [low];
    int low_temp = low, high_temp = high;
    while(low < high){
        while(low < high && A[high] > = pivot){
            high--;
        }
        A [low] = A [high];
        while(low < high && A [low] <= pivot){
            low++;
        }
        A [high] = A [low];
    }
    A [low] = pivot;
    if(low == k){
        return low;
    }else if( low > k){
        return Search_k(A, low_temp, low-1, k);
    }else{
        return Search_k(A, low+1, high_temp, k);
    }
}
```

### 5.21. å·²çŸ¥ä¸€ä¸ªæ•°ç»„Aå­˜å‚¨äº†nä¸ªå…ƒç´ ï¼Œä¸”æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸ç›¸åŒçš„æ­£æ•´æ•°ï¼Œè¯·è®¾è®¡ä¸€ä¸ªé«˜æ•ˆç®—æ³•æŠŠæ•°ç»„Aä¸­æ‰€æœ‰å¥‡æ•°ç§»åŠ¨åˆ°æ‰€æœ‰å¶æ•°å‰è¾¹çš„ç®—æ³•ã€‚

```c
void Move(int A [], int n){
    int low = 0, high = n-1, temp;
    while(low < high){
        while(low < high && A [low] % 2 != 0){
            low++;
        }
        while(low < high && A [low] % 2 != 1){
            high--;
        }
        if(low < high){
            temp = A [low];
            A [low] = A [high];
            A [high] = A [low];
            low++;
            high--;
        }
    }
}
```

### 5.22. é¡ºåºæ”¾ç½®nä¸ªçƒï¼Œæ¯ä¸ªçƒçš„é¢œè‰²æ˜¯çº¢ï¼Œç™½ï¼Œè“ä¹‹ä¸€ï¼Œè¦æ±‚é‡æ–°æ’åˆ—è¿™äº›çƒï¼Œä½¿å¾—æ‰€æœ‰çº¢è‰²çš„çƒåœ¨å‰ç™½è‰²çƒå±…ä¸­ï¼Œè“è‰²çš„çƒåœ¨åã€‚å‡è®¾æ”¾ç½®çƒçš„åºåˆ—å­˜æ”¾åœ¨æ•°ç»„Aä¸­ï¼Œ0ä»£è¡¨çƒä¸ºçº¢è‰²ï¼Œ1ä»£è¡¨çƒä¸ºç™½è‰² 2ä»£è¡¨çƒä¸ºè“è‰²ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•ä¸ºè¿™ä¸ªçƒæ’åºã€‚

```c
void Sort(int A [], int n){
    int low = 0, high = n-1, i = 0;
    while(i <= high){
        if(A [i] == 0){
            Swap(A [i], A [low]);
            low++;
            i++;
        }else if(A [i] == 1){
            i++;
        }else{
            Swap(A [i], A [high]);
            high--;
        }
    }
}
```

### 5.23. ç®€å•é€‰æ‹©æ’åº

::: code-group

```c [é¡ºåºå­˜å‚¨]
void SelectSort(int A []){
    int i, j, min, temp;
    for(i = 0, i < n-1; i++){
        min = i;
        for(j = i+1; i < n; j++){
            if(A [i] < A [min]){
                min = j;
            }
        }
        temp = A [i];
        A [i] = A [min];
        A [min] = temp;
    }
}
```

```c [é“¾å¼å­˜å‚¨]
void SelectSort(LinkList &L){
    LNode *pre, * p, *maxpre, * maxp;
    LNode *r = L; // è®°å½•å·²æ’å¥½åºçš„æœ€åä¸€ä¸ªç»“ç‚¹
    while(r-> next != NULL){
        pre = r;
        p = r-> next;
        maxpre = pre;
        max = p;
        // æ‰¾ maxp
        while(p != NULL){
            if(p-> data > maxp-> data){
                maxpre = pre;
                maxp = p;
            }
            pre = p;
            p = pre-> next;
        }
        // å¼€å§‹äº¤æ¢(å–ä¸‹ç»“ç‚¹)
        maxpre-> next = maxp-> next;
        // å¤´æ’å…¥ç»“ç‚¹
        maxp-> next = L-> next;
        L-> next == maxp;
        if(r == L){
            r = maxp;
        }
    }
}
```

:::

### 5.24. æœ‰ä¸€ç§ç®€å•çš„æ’åºç®—æ³•ç§°ä¸ºè®¡æ•°æ’åºï¼Œå…¶ç®—æ³•æ€æƒ³æ˜¯é€‰å–ä¸€ä¸ªå¾…æ’åºçš„å…ƒç´ å€¼ï¼Œç„¶åéå†æ•´ä¸ªæ•°ç»„ï¼Œç»Ÿè®¡æ•°ç»„ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ æ¯”é€‰å–çš„å¾…æ’åºå…ƒç´ å€¼å°ï¼Œå‡è®¾ç»Ÿè®¡å‡ºçš„è®¡æ•°å€¼ä¸ºC,åˆ™å¯ä»¥æ ¹æ®è®¡æ•°å€¼cåœ¨æ–°çš„æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°å¾…æ’åºå…ƒç´ çš„æœ€ç»ˆä½ç½®ã€‚ç°æœ‰ä¸€ä¸ªæ•°ç»„A,å­˜æ”¾äº†nä¸ªäº’ä¸ç›¸åŒçš„æ•´å‹å…ƒç´ ï¼Œè¯·ä½¿ç”¨è®¡æ•°æ’åºç®—æ³•ä¸ºæ•°ç»„Aæ’åºï¼Œæ’åºç»“æœå­˜æ”¾åœ¨æ•°ç»„Bä¸­ã€‚

```c
void Count(int A [], int B [], int n){
    int i, j;
    int count;
    for(i = 0; i < n; i++){
        for(j = 0, count = 0; j < n; j++){
            if(A [j] < A [i]){
                count++;
            }
        }
        B [count] = A [i];
    }
}
```

### 5.25. æœ‰ä¸€ä¸ªæ•°ç»„Aå­˜å‚¨äº†ä¸ªæ•´å‹å…ƒç´ ï¼Œå…ƒç´ ä»æ•°ç»„ä¸‹æ ‡1å¼€å§‹å­˜å‚¨ï¼Œè¯·å†™å‡ºå¯¹æ•°ç»„Aä½¿ç”¨å †æ’åºçš„ç®—æ³•

```c
void HeapAdjust(int A [], int n, int k){
    A [0] = A [k];
    int i = 2*k;
    while(i <= n){
        if(i < n && A[i+1] > A [i]){
            i++;
        }
        if(A [i] > A [0]){
            A [k] = A [i];
            k = i;
            i = 2*i;
        }else{
            break;
        }
    }
    A [k] = A [0];
}

void BuildMaxHeap(int A [], int n){
    for(int i = n/2; i > 0; i--){
        HeapAdjust(A, n, i);
    }
}

void HeapSort(int A [], int n){
    BuildMaxHeap(A, n);
    int temp;
    for(int i = n; i > 1; i--){
        temp = A [1];
        A [1] = A [i];
        A [i] = temp;
        HeapAdjust(A, i-1,1);
    }
}
```

### 5.26. è¯•è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­ä¸€ä¸ªæ•°æ®åºåˆ—æ˜¯å¦æ„æˆä¸€ä¸ªå°æ ¹å †ã€‚

```c
bool IsMinHeap(int A []ï¼Œint len){
    if(len%2 == 0ï¼‰{			//len ä¸ºå¶æ•°ï¼Œæœ‰ä¸€ä¸ªå•åˆ†æ”¯ç»“ç‚¹
    	if(A [len/2] > A [len])			//åˆ¤æ–­å•åˆ†æ”¯ç»“ç‚¹
    		return false;
        for(i = len/2-1; i >= 1; i--)	//åˆ¤æ–­æ‰€æœ‰åŒåˆ†æ”¯ç»“ç‚¹
            if(A [i] > A [2 *i] || A[i]> A[2* i+1])
                return false;
    else{						//len ä¸ºå¥‡æ•°æ—¶ï¼Œæ²¡æœ‰å•åˆ†æ”¯ç»“ç‚¹
    	for(i = len/2; i >= 1; i--)		//åˆ¤æ–­æ‰€æœ‰åŒåˆ†æ”¯ç»“ç‚¹
    		if(A [i] > A [2 *i] || A[i]> A[2* i+1])
    			return false;
    }
    return true;
}
```

### äºŒè·¯å½’å¹¶æ’åº

```c
void Merge(int sort [], int num [], int low, int mid, int high){
    int i = low;      //å·¦å­åºåˆ—èµ·ç‚¹ä¸‹æ ‡
    int j = mid+1;    //å³å­åºåˆ—èµ·ç‚¹ä¸‹æ ‡
    int k = low;      //ä¸´æ—¶æ•°ç»„çš„åˆå§‹åŒ–ä¸‹æ ‡
    while(i <= mid&&j <= high){//åœ¨å·¦å³å­åºåˆ—ä¸­æŒ‰ä»å°åˆ°å¤§é¡ºåºå­˜åˆ°ä¸´æ—¶æ•°ç»„ä¸­
        if(num [i] < num [j])
            sort [k++] = num [i++];
        else
            sort [k++] = num [j++];
    }
    //å°†å·¦å³å­åºåˆ—å‰©ä½™çš„æ•°ä¾æ¬¡å­˜å…¥ä¸´æ—¶æ•°ç»„
    while(i <= mid)
        sort [k++] = num [i++];
    while(j <= high)
        sort [k++] = num [j++];
    //å°†ä¸´æ—¶æ•°ç»„çš„æ•°æ®æŒ‰ä½ç½®å¤åˆ¶åˆ°åŸæ•°ç»„å¯¹åº”ä½ç½®ä¸Š
    while(--k >= 0)
        num [k] = sort [k];
}
void MergeSort(int sort [], int num [], int low, int high){
    if(low < high){
        int mid =(low+high)/2;           //åˆ†ä¸ºå·¦å³å­åºåˆ—çš„ä¸­é—´ä¸‹æ ‡
        MergeSort(sort, num, low, mid);    //é€’å½’å·¦å­åºåˆ—
        MergeSort(sort, num, mid+1, high); //é€’å½’å³å­åºåˆ—
        Merge(sort, num, low, mid, high);   //æ’åº
    }
}
```

## 6. å›¾

### 6.1. å›¾çš„é‚»æ¥çŸ©é˜µå­˜å‚¨ç»“æ„å®šä¹‰åŠå…¶åŸºæœ¬æ“ä½œ

```c
typedef struct MGraph{
    char Vex [MaxSize];
    int Edge [MaxSize][MaxSize];
    int vexnum, arcnum;
} MGraph;
```

### 6.2. å›¾çš„é‚»æ¥è¡¨å­˜å‚¨ç»“æ„å®šä¹‰åŠå…¶åŸºæœ¬æ“ä½œã€‚

```c
typedef struct ArcNode{
    int adjvex;
    struct ArcNode *nextarc;
} ArcNode;
typedef struct VNode{
    char data;
    ArcNode *firstarc;
} VNode;
typedef struct AGraph{
    VNode adjlist [MaxSize];
    int vexnum, arcnum;
} AGraph;
```

### 6.3. å†™å‡ºä»å›¾çš„é‚»æ¥è¡¨è¡¨ç¤ºè½¬æ¢æˆé‚»æ¥çŸ©é˜µè¡¨ç¤ºçš„ç®—æ³•

```c
void Func(MGraph &G1, AGraph *G2){
    G1.vexnum = G2-> vexnum; // å¤åˆ¶å€¼
    G1.arcnum = G2-> arcnum;
    for(int i = 0; iã€€< G2-> vexnum; i++){
        for(int j = 0; j < G2-> vexnum; j++){
            G1 [i][j] = 0; // åˆå§‹åŒ–
        }
    }
    ArcNode *p;
    for(int i = 0; i < G2-> vexnum; i++){
        G1.Vex [i] = G2-> adjlist [i].data;
        p = G2-> adjlist [i].firstarc;
        while(p != NULL){
            G1.Edge [i][p->adjvex] = 1;
            p = p-> nextarc;
        }
    }
}
```

### 6.4. å†™å‡ºä»å›¾çš„é‚»æ¥çŸ©é˜µè¡¨ç¤ºè½¬æ¢æˆé‚»æ¥è¡¨è¡¨ç¤ºçš„ç®—æ³•ã€‚

```c
void Func(MGraph G1; AGraph *G2){
    G2-> vexnum = G1.vexnum;
    G2-> arcnum = G1.vexnum;
    for(int i = 0; i < G1.vexnum; i++){ // ç»™é‚»æ¥è¡¨çš„ adjvex [] èµ‹å€¼
        G2-> adjlist [i].data = G1.Vex [i];
        G2-> adjlist [i].firstarc = NULL;
    }
    ArcNode *p;
    for(int i = 0; i < G1.vexnum; i++){
        for(int j = 0; j < G1.vexnum; j++){
            if(G1.Edge [i][j] != 0){
                p = (ArcNode *)malloc(sizeof(ArcNode));
                p-> adjvex = j; // åˆ›å»ºç»“ç‚¹ ArcNode
                p-> nextarc = G2-> adjlist [i].firstarc; // å¯¹é‚»æ¥è¡¨çš„ç»“ç‚¹æ•°ç»„è¿›è¡Œå¤´æ’æ“ä½œ
                G2-> adjlist [i].firstarc = p;
            }
        }
    }
}
```

### 6.5. è¯·å†™å‡ºä»¥é‚»æ¥çŸ©é˜µæ–¹å¼å­˜å‚¨å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•

```c
void BFS(MGraph G, int v, int visited []){
    Queue Q;
    InitQueue(Q);
    printf("%c", G.Vex [v]);
    visited [v] = 1;
    EnQueue(Q, v);
    -----------------------------
    while(! IsEmpty(Q)){ // é€å±‚éå†
        DeQueue(Q, v);
        for(int j = 0; j < G.vexnum; j++){ // ä¸€æ¬¡å¹¿åº¦éå†
            if(G.Edge [v][j] == 1 && visited [i] == 0){
                printf("%c", G.Vex [i]); // æ‰“å° ç½® 1 å…¥é˜Ÿ
                visited [j] = 1;
                EnQueue(Q, j);
            }
        }
    }
}
```

### 6.6. è¯·å†™å‡ºä»¥é‚»æ¥è¡¨æ–¹å¼å­˜å‚¨å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•

```c
void BFS(AGraph *G, int v, int visited []){
    Queue Q;
    InitQueue(Q);
    print("%c", G-> adjlist [v].data);
    visited [v] = 1;
    EnQueue(Q, v);
    ArcNode *p; // [! code highlight]
    while(! IsEmpty(Q)){
        DeQueue(Q, v);
        p = G-> adjlist [v].firstarc;
        while(p != NULL){ // [! code highlight]
            if(visited [p-> adjvex] == 0){
                printf("%c", G-> adjlist [p-> adjvex].data);
                visited [p-> adjvex] = 1;
                EnQueue(Q, p-> adjvex);
            }
        }
    }
}
```

### 6.7. è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ‰¾å‡ºé‚»æ¥è¡¨æ–¹å¼å­˜å‚¨çš„æ— å‘è¿é€šå›¾Gä¸­è·ç¦»é¡¶ç‚¹Væœ€è¿œçš„ä¸€ä¸ªé¡¶ç‚¹ã€‚ï¼ˆæ‰€è°“æœ€è¿œå°±æ˜¯åˆ°è¾¾vçš„è·¯å¾„é•¿åº¦æœ€é•¿)

```c
int Func(AGraph *G, int v, int visited []){
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    Queue Q;
    InitQueue(Q);
    visited [v] = 1;
    EnQueue(Q, v);
    ArcNode *p;
    while(! IsEmpty(Q)){
        DeQueue(Q, v); // æœ€åä¸€ä¸ªå‡ºé˜Ÿçš„ v å³æ‰€æ±‚
        p = G-> adjlist [v].firstarc;
        while(p != NULL){
            if(visited [p-> adjvex] == 0){
                visited [p-> adjvex] = 1;
                EnQueue(Q, p-> adjvex);
            }
            p = p-> nextarc;
        }
    }
    return v;
}
```

### 6.8. è¯·å†™å‡ºåˆ©ç”¨BFSç®—æ³•æ±‚è§£é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ä¸­å•æºæœ€çŸ­è·¯å¾„çš„ç®—æ³•ï¼Œ

```c
void BFS_MIN_Distance(AGraph *G, int v, int visited [], int d []){ // d [] è®°å½•è·ç¦»
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
        d [i] = INT_MAX;
    }
    Queue Q;
    InitQueue(Q);
    ArcNode *p;
    visited [v] = 1;
    d [v] = 0;
    EnQueue(Q, v);
    while(! IsEmpty(Q)){
        DeQueue(Q, v);
        p = G-> adjlist [v].firstarc;
        while(p != NULL){
            if(visited [p-> adjvex] == 0){
                visited [p-> adjvex] = 1;
                d [p-> adjvex] = d [v]+1; // æºé¡¶ç‚¹çš„è·ç¦»+1
                EnQueue(Q, v);
            }
            p = p-> nextarc;
        }
    }
}
```

### 6.9. è¯·å†™å‡ºä»¥é‚»æ¥çŸ©é˜µæ–¹å¼å­˜å‚¨å›¾çš„æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•ã€‚

```c
void DFS(MGraph G, int v, int visited []){
    printf("%c", G.Vex [v]);
    visited [v] = 1;
    for(int j; j < G.vexnum; j++){
        if(G.Edge [v][j] == 1 && visited [j] == 0){
            DFS(G, j, visited); // for + if + é€’å½’
        }
    }
}

void Func(MGraph G, int v){
    int visited [G.vexnum];
    for(int i = 0; i < G.vexnum; i++){
        visited [i] = 0;
    }
    DFS(G, v, visited);
    for(int i = 0; i < G.vexnum; i++){
        if(visited [i] == 0){
            DFS(G, i, visited);
        }
    }
}
```

### 6.10. è¯·å†™å‡ºä»¥é‚»æ¥è¡¨æ–¹å¼å­˜å‚¨å›¾çš„æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•

```c
void DFS(AGraph *G, int v, int visited []){
    printf("%c", G-> adjlist.data);
    visited [v] = 1;
    ArcNode *p;
    while(p != NULL){
        if(visited [p-> adjvex] == 0){
            DFS(G, p-> adjvex, visited);
        }
    }
}

void Func(AGraph *G, int v){
    int visited [G-> vexnum];
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    DFS(G, v, visited);
    for(int i = 0; i < G-> vexnum; i++){
        if(visited [i] == 0){
            DFS(G, i, visited);
        }
    }
}
```

### 6.11. æœ‰å‘å›¾Gä»¥é‚»æ¥è¡¨æ–¹å¼å­˜å‚¨ï¼Œè¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ¤æ–­å›¾Gä¸­é¡¶ç‚¹åˆ°é¡¶ç‚¹æ˜¯å¦å­˜åœ¨è·¯å¾„ã€‚iå’Œjä¸ç›¸ç­‰

```c
void DFS(AGraph *G, int v, int visited []){
    printf("%c", G-> adjlist.data);
    visited [v] = 1;
    ArcNode *p;
    while(p != NULL){
        if(visited [p-> adjvex] == 0){
            DFS(G, p-> adjvex, visited);
        }
    }
}

int Path_i_j(AGraph *G, int i, int j){
    int visited [G-> vexnum];
    for(int i = 0; i < G-> vexnum; i++){
        visited [k] = 0;
    }
    DFS(G, i, visited);
    if(visited [j] == 1){
        return 1;
    }else{
        return 0;
    }
}
```

### 6.12. è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ¤æ–­ä¸€ä¸ªé‚»æ¥è¡¨å­˜å‚¨çš„æ— å‘å›¾ä¸­æœ‰å‡ ä¸ªè¿é€šåˆ†é‡ã€‚

```c
void DFS(AGraph *G, int v, int visited []){
    printf("%c", G-> adjlist.data);
    visited [v] = 1;
    ArcNode *p;
    while(p != NULL){
        if(visited [p-> adjvex] == 0){
            DFS(G, p-> adjvex, visited);
        }
    }
}

int Func(AGraph *G){
    int visited [];
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    int count = 0;
    for(int i = 0; i < G-> vexnum; i++){
        if(visited [i] == 0){
            DFS(G, i, visited); // [! code highlight]
            count++; // [! code highlight]
        }
    }
    return count;
}
```

### 6.13. è¯•è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­ä¸€ä¸ªé‚»æ¥è¡¨å­˜å‚¨çš„æ— å‘å›¾Gæ˜¯å¦ä¸ºä¸€æ£µæ ‘ï¼Œ

```c
void DFS(AGraph *G, int v, int visited []){
    printf("%c", G-> adjlist.data);
    visited [v] = 1;
    ArcNode *p;
    while(p != NULL){
        if(visited [p-> adjvex] == 0){
            DFS(G, p-> adjvex, visited);
        }
    }
}
int IsTree(AGraph *G){
    int visited [G-> vexnum];
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    DFS(G, 0, visited);
    for(int i = 0; i < G-> vexnum; i++){
        if(visited [i] == 0){
            return 0;
        }
    }
    if(G-> arcnum == G-> vexnum-1){
        return 1;
    }else{
        return 0;
    }
}
```

### 6.14. æœ‰ä¸€ä¸ªé‚»æ¥çŸ©é˜µå½¢å¼å­˜å‚¨çš„è¿é€šå›¾G,è¯•å†™å‡ºå›¾Gæ·±åº¦ä¼˜å…ˆéå†çš„éé€’å½’ç®—æ³•ã€‚

```c
void DFS(MGraph G, int v, int visited []){
    for(int i = 0; i < G.vexnum; i++){
        visited [i] = 0;
    }
    Stack S;
    InitStack(S);
    printf("%c", G.Vex [v]);
    visited [v] = 1;
    Push(S, v);
    int j;
    while(! IsEmpty(S)){
        GetTop(S, v);
        for(j = 0; j < G.vexnum; j++){
            if(G.Edge [v][j] == 1 && visited [j] == 0){
                break;
            }
        }
        if(j == S.vexnum){
            Pop(S, v);
        }else{
            printf("%c", G.Vex [j]);
            visited [j] = 1;
            Push(S, j);
        }
    }
}
```

### æœ‰ä¸€ä¸ªé‚»æ¥è¡¨å½¢å¼å­˜å‚¨çš„è¿é€šå›¾G,è¯•å†™å‡ºå›¾Gæ·±åº¦ä¼˜å…ˆéå†çš„éé€’å½’ç®—æ³•

```c
void DFS(AGraph *G, int v, int visited []){
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    Stack S;
    InitStack(S);
    printf("%c", G-> adjlist [v].data);
    visited [v] = 1;
    Push(S, v);
    ArcNode *p;
    while(! IsEmpty(S)){
        GetTop(S, v);
        p = G-> adjlist [v].firstarc;
        while(p != NULL && visited [p-> adjvex] == 1){
            p = p-> nextarc;
        }
        if(p == NULL){
            Pop(S, v);
        }else{
            printf("%c", G-> adjlist [p-> adjvex].data);
            visited [p-> adjvex] = 1;
            Push(S, p-> adjvex);
        }
    }
}
```

### å‡è®¾å›¾ç”¨é‚»æ¥è¡¨è¡¨ç¤ºï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œè¾“å‡ºä»é¡¶ç‚¹uåˆ°é¡¶ç‚¹çš„æ‰€æœ‰ç®€å•è·¯å¾„

```c
void PrintPath(AGraph *G, int u, int v, int visited [], int path [], int d){
    d++;
    path [d] = G-> adjlist [u].data;
    visited [u] = 1;
    if(u == v){
        for(int i = 0; i <= d; i++){
            printf("%c", path [i]);
        }
        visited [u] = 0;
        return;
    }
    ArcNode *p = G-> adjlist [u].firstarc;
    while(p!= NULL){
        if(visited [p-> adjvex] == 0){
            PrintPath(G, p-> adjvex, v, visited, path, d);
        }
        p = p-> nextarc;
    }
    visited [u] = 0;
}
```

### è¯·å†™å‡ºé‚»æ¥è¡¨å­˜å‚¨å›¾çš„æ‹“æ‰‘æ’åºç®—æ³•

```c
typedef struct VNode{
    char data;
    int indegree;
    ArcNode *firstarc;
}
int Top(AGraph G){
    int i = 0, count = 0;
    ArcNode *p;
    Stack S;
    InitStack(S);
    // æ‰¾åˆ°åˆå§‹å…¥åº¦ä¸º 0 çš„é¡¶ç‚¹
    for(; i < G-> vexnum; i++){
        if(G-> adjlist [i].indegree == 0){
            Push(S, i);
        }
    }
    // è¿›è¡Œæ‹“è¡¥æ’åº
    while(! IsEmpty(S)){
        Pop(S, i);
        printf("%c", G-> adjlist [i].data);
        count++;
        p = G-> adjlist [i].firstarc;
        // å¯¹è¾¹è¡¨ç»“ç‚¹
        while(p != NULL){
            G-> adjlist [p-> adjvex].indegree--;
            if(G-> arclist [p-> adjvex].indegree == 0){
                Push(S, p-> adjvex);
            }
            p = p-> nextarc;
        }
    }
    // æ£€æŸ¥æ˜¯å¦æœ‰ç¯
    if(count == G-> vexnum){
        return 1;
    }else{
        return 0;
    }
}
```

### è¯·è®¾è®¡ä¸€ä¸ªç®—æ³•åˆ¤æ–­ä¸€ä¸ªé‚»æ¥è¡¨å­˜å‚¨çš„æ— å‘å›¾ä¸­æ˜¯å¦æœ‰ç¯ã€‚

```c
// åˆ¤æ–­æœ‰å‡ ä¸ªè¿é€šåˆ†é‡
int Func(AGraph *G){
    int visited [];
    for(int i = 0; i < G-> vexnum; i++){
        visited [i] = 0;
    }
    int count = 0;
    for(int i = 0; i < G-> vexnum; i++){
        if(visited [i] == 0){
            DFS(G, i, visited); // [! code highlight]
            count++; // [! code highlight]
        }
    }
    return count;
}

int Isloop(AGraph *G){
    int n = Func(G);
    if(G-> arcnum == G-> vexnum - 1){
        return 1;
    }else{
        return 0;
    }
}
```

### è¯·å†™å‡ºæ„é€ æœ€å°ç”Ÿæˆæ ‘çš„Primç®—æ³•

> ä¸¤ä¸ªæ•°ç»„,ä¸€ä¸ªè®°å½•æœ€å°è·ç¦»,ç”¨lowcost[j] = G.Edge\[k][j];æ›´æ–°,ä¸€ä¸ªç”¨äºæ ‡è®°æ˜¯å¦visited

```c
void Prim(MGraph G, int v){
    int visited [G.vexnum];
    int lowcost [G.vexnum];
    // åˆå§‹åŒ–ä¸¤ä¸ªæ•°ç»„
    for(int i = 0; i < G.vexnum; i++){
        visited = 0;
        lowcost = G.Edge [v][i];
    }
    printf("%d", G.Vex [v]);
    visited [v] = 1;
    int min, k;
    for(int i = 0; i < G.vexnum - 1; i++){
        min = INT_MAX;
        // æ‰¾åˆ°è·ç¦»æœ€å°çš„ç»“ç‚¹
        for(int j = 0; j < G.vexnum; j++){
            if(visited [j] == 0 && lowcost [j] < min){
                min = lowcost [j];
                k = j;
            }
        }
        printf("%d", G.Vex [k]);
        visited [k] = 1;
        // æ•°ç»„æ›´æ–°
        for(int j = 0; j < G.vexnum; j++){
            if(visited [j] == 0 && G.Edge [k][j] < lowcost [j]){
                lowcost [j] = G.Edge [k][j];
            }
        }
    }
}
```

### è¯·å†™å‡ºæ„é€ æœ€å°ç”Ÿæˆæ ‘çš„Kruskalç®—æ³•<span style="font-size:0.6em; color:#FFFF66;">(ä¸¤é¡µå¤š,å†™ä¸ªé’©å­å“¦)</span>

```c
å•Šå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆ ~~~~ â•°ï¼ˆâ€µâ–¡â€²ï¼‰â•¯
```

### è¯·å†™å‡ºæ±‚å•æºæœ€çŸ­è·¯å¾„çš„Dijkstraç®—æ³•

```c
void Dijkstra(MGraph G, int v){
    int visited [G.vexnum];
    int dist [G.vexnum]; // è®°å½•å•å…ƒæœ€çŸ­è·¯å¾„
    int path [G.vexnum]; // è®°å½•å…¥åº¦çš„ç»“ç‚¹
    for(int i = 0; i < G.vexnum; i++){
        visited [i] = 0;
    }
    for(int i = 0; i < G.vexnum; i++){
        dist [i] = G.Edge [v][i];
        path [i] = v;
    }
    visited [v] = 1;
    int min, k;
    for(int i = 0; i < G.vexnum; i++){
        min = INT_MAX;
        for(int j = 0; j < G.vexnum; j++){
            if(visited [j] == 0 && dist [j] < min){
                min = dist [j];
                k = j;
            }
        }
        visited [k] = 1;
        for(int j = 0; j < G.vexnum; j++){
            if(visited [j] == 0 && dist [k] + G.Edge [k][j] < dist [j]){
                dist [j] = dist [k] + G.Edge [k][j];
                path [j] = k;
            }
        }
    }
}
```

### Floydç®—æ³•

```c
ä»€ä¹ˆç©æ„å•Š
```

## 408çœŸé¢˜

### 2015å¹´:

![image-20241009150842177](https://img.picgo.net/2024/10/09/image-2024100915084217782ed78d1b6396be4.png)

```c
void Func(LinkList &HEAD, int n){
    int *A = (int *)malloc(sizeof(int) * (n+1));
    for(int i = 0; i < n+1; i++){
        A [i] = 0;
    }
    int *pre = HEAD, p = HEAD-> link;
    int m; // ç”¨äºæ¥æ”¶ç»å¯¹å€¼
    while(p != NULL){
        m = p-> data > 0 ? p-> data : -(p-> data);
        if(A [p-> data] == 0){
            A [p-> data] = 1;
            pre = p;
            p = p-> link;
        }else{
            pre-> link = p-> link;
            free(p);
            p = pre-> link;
        }
    }
    free(A);
}
```

### 2016å¹´:

![image-20241009154143738](https://img.picgo.net/2024/10/09/image-202410091541437389165d47bf15b48bf.png)

```c
// T: O(n)  S: O(1)
int Func(int A [], int n){
    int low = 0, high = n-1, k = n/2 - 1, flag = 1, low_twmp = 0, high_temp = n-1;
    int S1 = 0, S2 = 0, pivot;
    while(flag){
        pivot = A [low];
        while(low < high){
            while(low < high && A[high] > pivot){
                high--;
            }
            A [low] = A [high];
            while(low < high && A [low] < pivot){
                low++;
            }
            A [high] = A [low];
        }
        if(low == k){
            flag = 0;
        }else if(low > k){
            high--;
            high_temp = high;
            low = low_temp;
        }else{
            low++;
            low_temp = low;
            high = high_temp;
        }
    }
    for(int i = 0; i < k+1; i++){
        S1 = S1+A [i];
    }
    for(int i = k+1, i < n; i++){
        S2 = S2+A [i];
    }
    return S2-S1;
}
```

### 2017å¹´:

![image-20241009155406110](https://img.picgo.net/2024/10/09/image-202410091554061100c48c131b2337ea1.png)

```c
void Func(BTree *T, int deep){ // åˆå§‹ä¼ å…¥ 1
    if(T != NULL){
        if(T-> lchild == NULL && T-> rchild == NULL){
            printf("%s", T);
        }else{
            if(deep > 1){
                printf("(");
            }
            Func(T-> lchild, deep+1);
            printf("%s", T-> data);
            Func(T-> rchild, deep+1);
            if(deep > 1){
                printf(")");
            }
        }
    }
}
```

### 2018å¹´:

![image-20241010200411167](https://img.picgo.net/2024/10/10/image-20241010200411167f24467998f938092.png)

```c
int Func(int A [], int n){
    int *B = (int*)malloc(sizeof(int)*(n+1));
    int k;
    for(int i = 0; i <= n; i++){
        B [i] = 0;
    }
    for(int i = 0; i < n; i++){
        if(A [i] > 0 && A [i] <= n){
            B [A[i]] = 1;
        }
    }
    for(k = 1; k <= n; k++){
        if(B [k] = 0){
            break;
        }
    }
    return k;
}
```

### 2019å¹´:

![image-20241010203348101](https://img.picgo.net/2024/10/10/image-202410102033481018a53a3bc93a86a5a.png)

```c
// åˆ†æ®µ é€†ç½® åˆå¹¶
void Func(NODE *&L){
    NODE *p = L,* q = L,*r;
    while(q-> next != NULL){
        p = p-> next;
        q = q-> next;
        if(Q-> next != NULL){
            q = q-> next;
        }
    }
    q = p-> next;
    p-> next = NULL;
    while(q != NULL){
        r = q-> next;
        q-> next = p-> next;
        p-> next = q;
        p = r;
    }
    q = p-> next;
    p-> next = NULL;
    p = L-> next;
    while(p != NULL){
        r = q-> next;
        q-> next = p-> next;
        p-> next = q;
        p = q-> next;
        q = r;
    }
}
```

### 2020å¹´:

![image-20241010204240855](https://img.picgo.net/2024/10/12/ss5jrg2y492jy8tzenmvywfmpkh12nm85d7a99a1ffcbb137.png)

```c
int Func(int A [], int m, int B [], int n, int C [], int p){
    int i = 0, j = 0, k = 0, D;
    int D_MIN = MAX_INT;
    while(i < m && j < n && k < p){
        D = abs(A [i] - B [j]) + abs(A [i] - C [k]) + abs(B [j] - C [k]);
        if(D > D_MIN){
            D_MIN = D;
        }
        if(A [i] <= B [j] && A [i] <= C [k]){
            i++;
        }else if(B [j] <= C [k] && B [j] <= A [i]){
            j++;
        }else{
            k++;
        }
    }
    return D_MIN;
}
```
